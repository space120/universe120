<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Universe120 — Architect • Sim Lab</title>
<style>
:root{--bg:#f7f7fb;--card:#ffffffcc;--ink:#111;--muted:#666;--border:#e7e7ee;--brand:#3538ff}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
.site-header,.site-footer{position:fixed;left:0;right:0;display:flex;align-items:center;gap:16px;background:#fff8;backdrop-filter:saturate(1.8) blur(8px);border-bottom:1px solid var(--border);z-index:20}
.site-header{top:0;padding:10px 16px}
.site-footer{bottom:0;justify-content:center;border-top:1px solid var(--border);border-bottom:none;padding:8px 16px}
.brand{font-weight:800}
#ui.panel{position:fixed;left:16px;top:64px;z-index:15;background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px 14px;max-width:460px;box-shadow:0 6px 22px rgba(0,0,0,.07)}
#ui h1{margin:.25rem 0 .5rem;font-size:18px}
.row{display:flex;gap:8px;align-items:center;margin:.35rem 0}
label{font-size:12px;color:#444;min-width:120px}
input[type=range]{flex:1}
select,input[type=checkbox],input[type=number],input[type=text]{font-size:13px}
fieldset{border:1px dashed var(--border);border-radius:10px;padding:8px 10px;margin:.5rem 0 0}
fieldset legend{font-size:12px;color:#333;padding:0 6px}
button{appearance:none;border:1px solid var(--border);background:#fff;border-radius:10px;padding:8px 12px;font-size:13px;cursor:pointer}
button:hover{background:#f6f6ff}
button.primary{background:#3538ff;color:#fff;border-color:#3538ff}
.badge{font-size:11px;padding:2px 8px;border:1px solid var(--border);border-radius:999px;background:#fff}
.kbd{background:#eee;border:1px solid #ccc;border-bottom-color:#bbb;border-radius:4px;padding:0 4px;font-family:ui-monospace,Menlo,Consolas,monospace}
#canvas{display:block;width:100vw;height:100vh}
.overlay{position:fixed;right:16px;top:64px;z-index:16;background:var(--card);border:1px solid var(--border);border-radius:12px;padding:10px 12px;max-width:460px;box-shadow:0 6px 22px rgba(0,0,0,.07);font-size:13px}
@media (max-width: 640px){
  #ui.panel { max-width: 92vw; left: 4vw; }
  .row button, .row select, .row input[type=range], .row input[type=number], .row input[type=text] { min-height: 40px; }
}
/* Password gate */
#gate{position:fixed;inset:0;background:#0a0a0f;color:#eee;display:flex;align-items:center;justify-content:center;z-index:9999}
#gate .box{width:min(90vw,460px);background:#14141b;border:1px solid #2a2a35;border-radius:14px;padding:22px;box-shadow:0 10px 40px rgba(0,0,0,.35);text-align:center}
#gate input{width:100%;padding:12px;border-radius:10px;border:1px solid #39394a;background:#0e0e15;color:#eaeaf2}
#gate button{width:100%;margin-top:10px;background:#3538ff;color:#fff;border:0;padding:12px;border-radius:10px;font-size:15px}
</style>
</head>
<body>
<!-- ====== PASSWORD GATE ====== -->
<div id="gate" aria-modal="true">
  <div class="box">
    <h2>Universe120 — Private Build</h2>
    <p>Enter access key to view.</p>
    <input id="gateKey" type="password" placeholder="••••••">
    <button id="gateBtn">Enter</button>
    <small>Tip: set <b>ACCESS_KEY</b> in the code to change/disable.</small>
  </div>
</div>

<header class="site-header">
  <div class="brand">Universe120 <span class="badge">Architect • Sim Lab</span></div>
</header>

<aside id="ui" class="panel" hidden>
  <h1>Toolkit</h1>
  <div class="row">
    <label for="mode">Mode</label>
    <select id="mode">
      <option value="architect2d" selected>2D Architect</option>
      <option value="simlab">Sim Lab (Math & Physics)</option>
    </select>
  </div>

  <!-- 2D Architect -->
  <fieldset id="arch2dBlock">
    <legend>2D Architect</legend>
    <div class="row"><label>Tool</label>
      <select id="tool2d">
        <option value="segment" selected>Segment</option>
        <option value="poly">Polyline (walls)</option>
        <option value="arc">Arc (two clicks)</option>
        <option value="circle">Circle (grid radius)</option>
        <option value="dim">Dimension</option>
        <option value="door">Door (swing)</option>
        <option value="window">Window</option>
        <option value="label">Room Label</option>
        <option value="erase">Erase</option>
      </select>
    </div>

    <div class="row"><label>Snap</label>
      <select id="snap2d">
        <option value="intersections" selected>Intersections</option>
        <option value="centers">Circle Centers</option>
        <option value="midpoints">Midpoints</option>
        <option value="free">Free</option>
      </select>
    </div>

    <div class="row"><label>Angle Lock</label>
      <select id="lockAngle">
        <option value="off" selected>Off</option>
        <option value="ortho">0/90°</option>
        <option value="thirty">30/60/90°</option>
        <option value="fortyfive">45/90°</option>
      </select>
    </div>

    <div class="row"><label>Wall (px)</label><input id="wallThick" type="number" min="0" max="60" step="1" value="10"></div>
    <div class="row"><label>Stroke</label><input id="stroke2d" type="range" min="0.6" max="3" step="0.1" value="1.4"></div>

    <div class="row"><label>View</label>
      <span><input type="checkbox" id="lockView" checked> Lock View</span>
      <button id="recenter2d" type="button">Recenter</button>
      <button id="zoomReset2d" type="button">Reset Zoom</button>
    </div>

    <div class="row"><button id="undo2d">Undo</button><button id="clear2d">Clear</button><button id="exportSvg" class="primary">Export SVG</button></div>

    <div class="row"><label>Background</label><input id="bgUpload" type="file" accept="image/*"></div>
    <div class="row"><label>BG Opacity</label><input id="bgAlpha" type="range" min="0" max="1" step="0.01" value="0.5"></div>
    <div class="row"><label>BG Scale</label><input id="bgScale" type="range" min="0.1" max="4" step="0.01" value="1"></div>
    <div class="row"><label>BG Rotate</label><input id="bgRot" type="range" min="-180" max="180" step="1" value="0"></div>
    <div class="row"><label>BG Offset</label><input id="bgOffX" type="number" value="0" style="width:80px"> <input id="bgOffY" type="number" value="0" style="width:80px"></div>
    <div class="row"><label>Calibrate</label><button id="calibStart">Pick 2 pts</button><input id="calibSteps" type="number" min="1" max="50" step="1" value="4" style="width:80px"></div>
    <p style="font-size:11px;color:#666">Tips: <span class="kbd">Shift</span> stronger snap • Double-click ends polyline • Locked view keeps you from “losing” your plan on zoom</p>
  </fieldset>

  <!-- Sim Lab -->
  <fieldset id="simBlock" style="display:none">
    <legend>Sim Lab (Math & Physics)</legend>
    <div class="row"><label>Mode</label>
      <select id="simMode">
        <option value="learn" selected>Learn (guided)</option>
        <option value="answer">Answer (quick)</option>
      </select>
    </div>
    <div class="row"><label>Scenario</label>
      <select id="scenario">
        <option value="projectile" selected>Projectile Motion</option>
        <option value="incline">Inclined Plane (μ)</option>
        <option value="circular">Circular Motion</option>
        <option value="vectors">Vector Addition</option>
        <option value="quadratic">Quadratic Grapher</option>
      </select>
    </div>

    <!-- Controls change per scenario -->
    <div id="controls"></div>
    <div class="row"><label>View</label><button id="resetSim">Reset</button></div>
    <p style="font-size:11px;color:#666">Drag in canvas to rotate (3D scenes) • Wheel to zoom • Learn = step-by-step walkthrough</p>
  </fieldset>
</aside>

<div id="coach" class="overlay" hidden></div>
<canvas id="canvas" hidden></canvas>

<footer class="site-footer">
  <small>© <span id="year"></span> Universe120 • Learn by building & simulating</small>
</footer>

<script>
/* ===== CONFIG ===== */
const ACCESS_KEY = ''; setTimeout(()=>openSite(),0);
/* ================== */
document.getElementById('year').textContent = new Date().getFullYear();

/* Gate */
const gate = document.getElementById('gate');
const gateBtn = document.getElementById('gateBtn');
const gateKey = document.getElementById('gateKey');
function openSite(){ gate.remove(); document.getElementById('ui').hidden=false; document.getElementById('canvas').hidden=false; document.getElementById('coach').hidden=false; startApp(); }
function tryGate(){ if(ACCESS_KEY==='' || gateKey.value===ACCESS_KEY) openSite(); else alert('Incorrect key'); }
gateBtn.addEventListener('click', tryGate);
gateKey.addEventListener('keydown', e=>{ if(e.key==='Enter') tryGate(); });
if(ACCESS_KEY==='') openSite();

/* ===== APP ===== */
function startApp(){
const canvas = document.getElementById('canvas');
const coach = document.getElementById('coach');
const ctx = canvas.getContext('2d',{alpha:true});
let DPR = Math.min(devicePixelRatio||1,2);
function resize(){ const w=innerWidth,h=innerHeight; canvas.style.width=w+'px'; canvas.style.height=h+'px'; canvas.width=Math.round(w*DPR); canvas.height=Math.round(h*DPR); ctx.setTransform(DPR,0,0,DPR,0,0); }
addEventListener('resize',resize); resize();

const $=id=>document.getElementById(id);
const ui={
  mode:$('mode'),
  // 2D
  arch2dBlock:$('arch2dBlock'), tool2d:$('tool2d'), snap2d:$('snap2d'), lockAngle:$('lockAngle'),
  wallThick:$('wallThick'), stroke2d:$('stroke2d'),
  lockView:$('lockView'), recenter2d:$('recenter2d'), zoomReset2d:$('zoomReset2d'),
  undo2d:$('undo2d'), clear2d:$('clear2d'), exportSvg:$('exportSvg'),
  bgUpload:$('bgUpload'), bgAlpha:$('bgAlpha'), bgScale:$('bgScale'), bgRot:$('bgRot'), bgOffX:$('bgOffX'), bgOffY:$('bgOffY'),
  calibStart:$('calibStart'), calibSteps:$('calibSteps'),
  // Sim Lab
  simBlock:$('simBlock'), simMode:$('simMode'), scenario:$('scenario'), controls:$('controls'), resetSim:$('resetSim')
};
ui.mode.addEventListener('change', ()=>{
  ui.arch2dBlock.style.display = ui.mode.value==='architect2d' ? '' : 'none';
  ui.simBlock.style.display    = ui.mode.value==='simlab' ? '' : 'none';
  coach.innerHTML = '';
  render(0,true);
});

/* ===== 2D Architect (locked grid) ===== */
let pan={x:0,y:0}, zoom=1;
const ORIGIN={x:0,y:0};
ui.recenter2d.addEventListener('click', ()=>{ pan.x=0; pan.y=0; });
ui.zoomReset2d.addEventListener('click', ()=>{ zoom=1; });

const Rbase=26;
function gridParams(){ const R=Rbase*zoom, stepX=R, stepY=R*Math.sqrt(3)/2; return {R,stepX,stepY}; }

const sketch=[]; // primitives including annotations
let polyLive=null, arcStart=null, dimStart=null, doorStart=null, winStart=null, labelPending=false;

function centersNear(x,y,range=3){
  const {stepX,stepY}=gridParams();
  const rr=Math.round(y/stepY), cc=Math.round((x-(rr%2? stepX/2:0))/stepX);
  const pts=[];
  for(let dr=-range;dr<=range;dr++)
    for(let dc=-range;dc<=range;dc++){
      const r=rr+dr,c=cc+dc,gx=c*stepX+(r%2? stepX/2:0), gy=r*stepY;
      pts.push({x:gx,y:gy,kind:'center'});
    }
  // midpoints
  const mids=[];
  for(let i=0;i<pts.length;i++){
    const a=pts[i];
    for(let j=i+1;j<pts.length;j++){
      const b=pts[j]; if(Math.hypot(a.x-b.x,a.y-b.y) < stepX*1.05){ mids.push({x:(a.x+b.x)/2,y:(a.y+b.y)/2,kind:'mid'}); }
    }
  }
  return pts.concat(mids);
}
function snap2D(clientX,clientY,strong){
  const {stepX,stepY}=gridParams();
  if(ui.snap2d.value==='free') return {x:clientX,y:clientY};
  const x = clientX - (pan.x % stepX);
  const y = clientY - (pan.y % stepY);
  const cand = centersNear(x,y,strong?4:3);
  let best=null,bd=1e9;
  cand.forEach(p=>{
    const sx=p.x + (pan.x % stepX), sy=p.y + (pan.y % stepY);
    const d2=(sx-clientX)*(sx-clientX)+(sy-clientY)*(sy-clientY);
    if(d2<bd){bd=d2; best={x:sx,y:sy,kind:p.kind};}
  });
  return best || {x:clientX,y:clientY};
}
function applyAngleLock(a0,a1,mode){
  if(mode==='off') return a1;
  const dx=a1.x-a0.x, dy=a1.y-a0.y, ang=Math.atan2(dy,dx);
  let snaps=[];
  if(mode==='ortho') snaps=[0,Math.PI/2,Math.PI,3*Math.PI/2];
  else if(mode==='thirty') snaps=[0,Math.PI/6,Math.PI/3,Math.PI/2,2*Math.PI/3,5*Math.PI/6,Math.PI,7*Math.PI/6,4*Math.PI/3,3*Math.PI/2,5*Math.PI/3,11*Math.PI/6];
  else if(mode==='fortyfive') snaps=[0,Math.PI/4,Math.PI/2,3*Math.PI/4,Math.PI,5*Math.PI/4,3*Math.PI/2,7*Math.PI/4];
  let best=ang,bd=1e9; snaps.forEach(s=>{const d=Math.abs(((ang-s+Math.PI)%(2*Math.PI))-Math.PI); if(d<bd){bd=d;best=s;}});
  const len=Math.hypot(dx,dy);
  return {x:a0.x+Math.cos(best)*len,y:a0.y+Math.sin(best)*len};
}

function drawGrid(){
  const {R,stepX,stepY}=gridParams();
  const w=canvas.width/DPR,h=canvas.height/DPR;
  ctx.save();
  ctx.translate((w/2 + ORIGIN.x) % stepX, (h/2 + ORIGIN.y) % stepY);
  ctx.lineWidth=0.9; ctx.strokeStyle='#00000018';
  const cols=Math.ceil(w/stepX)+4, rows=Math.ceil(h/stepY)+4;
  for(let r=-2;r<rows;r++){
    for(let c=-2;c<cols;c++){
      const x=c*stepX+(r%2? stepX/2:0), y=r*stepY;
      ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.stroke();
    }
  }
  ctx.restore();
}

/* Background image (photo align) */
const bg={img:null, alpha:0.5, scale:1, rot:0, offX:0, offY:0, calib:[]};
ui.bgUpload.addEventListener('change', (e)=>{
  const file=e.target.files[0]; if(!file) return;
  const fr=new FileReader(); fr.onload=()=>{ const im=new Image(); im.onload=()=>{ bg.img=im; render(0,true); }; im.src=fr.result; }; fr.readAsDataURL(file);
});
ui.bgAlpha.addEventListener('input', ()=>{ bg.alpha=+ui.bgAlpha.value; });
ui.bgScale.addEventListener('input', ()=>{ bg.scale=+ui.bgScale.value; });
ui.bgRot.addEventListener('input',  ()=>{ bg.rot=+ui.bgRot.value*Math.PI/180; });
ui.bgOffX.addEventListener('input', ()=>{ bg.offX=+ui.bgOffX.value; });
ui.bgOffY.addEventListener('input', ()=>{ bg.offY=+ui.bgOffY.value; });

ui.calibStart.addEventListener('click', ()=>{
  bg.calib=[]; alert('Calibration: click two points on the photo that should be N grid steps apart (set N).');
  calibMode=true;
});
let calibMode=false;
canvas.addEventListener('click', e=>{
  if(ui.mode.value!=='architect2d' || !calibMode || !bg.img) return;
  const p={x:e.clientX, y:e.clientY}; bg.calib.push(p);
  if(bg.calib.length===2){
    const N= Math.max(1, +ui.calibSteps.value||4);
    const dx=bg.calib[1].x - bg.calib[0].x, dy=bg.calib[1].y - bg.calib[0].y;
    const dist=Math.hypot(dx,dy);
    const {stepX}=gridParams();
    const target = N*stepX;
    const s = target / dist;
    bg.scale *= s;
    bg.rot = Math.atan2(dy,dx); // align to grid x-axis
    // snap first pick to nearest grid center
    const snapped = snap2D(bg.calib[0].x, bg.calib[0].y, true);
    bg.offX += snapped.x - bg.calib[0].x;
    bg.offY += snapped.y - bg.calib[0].y;
    ui.bgScale.value = bg.scale.toFixed(2);
    ui.bgRot.value   = Math.round(bg.rot*180/Math.PI);
    ui.bgOffX.value  = Math.round(bg.offX);
    ui.bgOffY.value  = Math.round(bg.offY);
    calibMode=false; bg.calib=[];
    alert('Calibrated. Fine-tune with the sliders if needed.');
  }
});

/* Architect drawing + annotations */
ui.undo2d.addEventListener('click', ()=>{ sketch.pop(); render(0,true); });
ui.clear2d.addEventListener('click', ()=>{ sketch.length=0; render(0,true); });
ui.exportSvg.addEventListener('click', exportSVG);

function exportSVG(){
  const w=canvas.width/DPR,h=canvas.height/DPR;
  const p=[]; p.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" fill="none" stroke="#111" stroke-width="${+ui.stroke2d.value}">`);
  sketch.forEach(d=>{
    if(d.type==='seg') p.push(`<line x1="${d.a.x}" y1="${d.a.y}" x2="${d.b.x}" y2="${d.b.y}"/>`);
    if(d.type==='circ') p.push(`<circle cx="${d.c.x}" cy="${d.c.y}" r="${d.r}"/>`);
    if(d.type==='arc'){
      const x1=d.c.x+d.r*Math.cos(d.a1), y1=d.c.y+d.r*Math.sin(d.a1);
      const x2=d.c.x+d.r*Math.cos(d.a2), y2=d.c.y+d.r*Math.sin(d.a2);
      p.push(`<path d="M ${x1} ${y1} A ${d.r} ${d.r} 0 0 ${d.ccw?1:0} ${x2} ${y2}"/>`);
    }
    if(d.type==='dim'){
      p.push(`<line x1="${d.a.x}" y1="${d.a.y}" x2="${d.b.x}" y2="${d.b.y}"/>`);
      p.push(`<line x1="${d.ta.x}" y1="${d.ta.y}" x2="${d.tb.x}" y2="${d.tb.y}"/>`);
      p.push(`<line x1="${d.h1.x}" y1="${d.h1.y}" x2="${d.a.x}" y2="${d.a.y}"/>`);
      p.push(`<line x1="${d.h2.x}" y1="${d.h2.y}" x2="${d.b.x}" y2="${d.b.y}"/>`);
      p.push(`<text x="${d.label.x}" y="${d.label.y}" font-size="12" fill="#111">${d.text}</text>`);
    }
    if(d.type==='door' || d.type==='window'){
      p.push(`<line x1="${d.a.x}" y1="${d.a.y}" x2="${d.b.x}" y2="${d.b.y}"/>`);
      if(d.type==='door'){
        p.push(`<path d="M ${d.a.x} ${d.a.y} A ${d.r} ${d.r} 0 0 ${d.ccw?1:0} ${d.arc.x} ${d.arc.y}"/>`);
      }
    }
    if(d.type==='label'){
      p.push(`<text x="${d.p.x}" y="${d.p.y}" font-size="14" fill="#111">${d.text}</text>`);
    }
  });
  p.push(`</svg>`);
  const blob = new Blob([p.join('\n')], {type:'image/svg+xml'});
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='universe120-architect.svg'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1500);
}

let dragging=false, lastX=0,lastY=0, spacePan=false;
function addSeg(A,B){ const wall=+ui.wallThick.value||0; sketch.push({type:'seg', a:A, b:B, wall}); }
function dimObj(A,B){
  // offset dimension line outward
  const off=16, nx=B.y-A.y, ny=-(B.x-A.x), L=Math.hypot(nx,ny)||1, ux=nx/L, uy=ny/L;
  const ta={x:A.x+ux*off,y:A.y+uy*off}, tb={x:B.x+ux*off,y:B.y+uy*off};
  const h1={x:ta.x-ux*6, y:ta.y-uy*6}, h2={x:tb.x+ux*6, y:tb.y+uy*6};
  const dist = Math.hypot(B.x-A.x,B.y-A.y);
  return {type:'dim', a:A,b:B, ta,tb, h1,h2, label:{x:(ta.x+tb.x)/2, y:(ta.y+tb.y)/2-6}, text:dist.toFixed(1)+' px'};
}

canvas.addEventListener('mousedown', e=>{
  if(ui.mode.value!=='architect2d'){ dragging=true; lastX=e.clientX; lastY=e.clientY; return; }
  if(e.button!==0) return;
  const strong=e.shiftKey; let P = snap2D(e.clientX,e.clientY,strong);
  const tool=ui.tool2d.value;

  if(tool==='segment' || tool==='poly'){
    if(!polyLive) polyLive={points:[P]};
    else{
      let A=polyLive.points[polyLive.points.length-1], B=P;
      B = applyAngleLock(A,B,ui.lockAngle.value);
      polyLive.points.push(B); addSeg(A,B);
      if(tool==='segment') polyLive=null;
    }
  } else if(tool==='arc'){
    if(!arcStart) arcStart=P;
    else{
      const mx=(arcStart.x+P.x)/2, my=(arcStart.y+P.y)/2, r=Math.hypot(P.x-arcStart.x,P.y-arcStart.y)/2;
      const a1=Math.atan2(arcStart.y-my,arcStart.x-mx), a2=Math.atan2(P.y-my,P.x-mx);
      sketch.push({type:'arc', c:{x:mx,y:my}, r, a1, a2, ccw:false}); arcStart=null;
    }
  } else if(tool==='circle'){
    const {R}=gridParams(); sketch.push({type:'circ', c:{x:P.x,y:P.y}, r:R});
  } else if(tool==='dim'){
    if(!dimStart) dimStart=P;
    else { sketch.push(dimObj(dimStart,P)); dimStart=null; }
  } else if(tool==='door'){
    if(!doorStart) doorStart=P;
    else{
      const A=doorStart, B=P; const r=Math.hypot(B.x-A.x,B.y-A.y); // interpret as radius (door width)
      const mid={x:(A.x+B.x)/2,y:(A.y+B.y)/2};
      // swing arc from A to a 90° rotation point
      const ang=Math.atan2(B.y-A.y,B.x-A.x);
      const arcEnd={x:A.x+r*Math.cos(ang+Math.PI/2), y:A.y+r*Math.sin(ang+Math.PI/2)};
      sketch.push({type:'door', a:A,b:B, r, ccw:true, arc:arcEnd});
      doorStart=null;
    }
  } else if(tool==='window'){
    if(!winStart) winStart=P;
    else{
      const A=winStart,B=P; sketch.push({type:'window', a:A,b:B}); winStart=null;
    }
  } else if(tool==='label'){
    if(!labelPending){ labelPending=true; const text=prompt('Room name / label:','Living Room'); if(text){ sketch.push({type:'label', p:P, text}); } labelPending=false; }
  } else if(tool==='erase'){
    let bi=-1, bd=1e9;
    sketch.forEach((d,i)=>{
      let cx=0,cy=0;
      if(d.type==='seg'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;}
      else if(d.type==='arc'){cx=d.c.x;cy=d.c.y;}
      else if(d.type==='circ'){cx=d.c.x;cy=d.c.y;}
      else if(d.type==='dim'){cx=d.label.x;cy=d.label.y;}
      else if(d.type==='door'||d.type==='window'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;}
      else if(d.type==='label'){cx=d.p.x;cy=d.p.y;}
      const dd=(cx-P.x)*(cx-P.x)+(cy-P.y)*(cy-P.y); if(dd<bd){bd=dd; bi=i;}
    });
    if(bi>=0) sketch.splice(bi,1);
  }
  render(0,true);
});
addEventListener('dblclick', e=>{ if(ui.mode.value==='architect2d' && ui.tool2d.value==='poly' && polyLive) polyLive=null; });
addEventListener('mousemove', e=>{
  if(ui.mode.value==='architect2d'){
    if(!ui.lockView.checked && (spacePan || dragging)){ pan.x += (e.movementX||0); pan.y += (e.movementY||0); }
  } else if(dragging){ rot.xy += (e.movementX||0)*0.005; rot.xz += (e.movementY||0)*0.005; }
});
addEventListener('mouseup', ()=>{ dragging=false; });
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const f=Math.exp(-e.deltaY*0.001);
  if(ui.mode.value==='architect2d'){
    const before=zoom; zoom = Math.max(0.25, Math.min(5, zoom*f));
    if(ui.lockView.checked){ pan.x=0; pan.y=0; }
    else{ const w=canvas.width/DPR,h=canvas.height/DPR,cx=w/2,cy=h/2; pan.x = cx - (cx - pan.x) * (zoom/before); pan.y = cy - (cy - pan.y) * (zoom/before); }
  } else {
    scale3d = Math.max(0.3, Math.min(3.0, scale3d * f));
  }
},{passive:false});
addEventListener('keydown', e=>{ if(e.code==='Space'){ spacePan=true; dragging=true; } });
addEventListener('keyup',   e=>{ if(e.code==='Space'){ spacePan=false; dragging=false; } });

function drawBackground(){
  if(!bg.img) return;
  const w=canvas.width/DPR,h=canvas.height/DPR;
  ctx.save(); ctx.globalAlpha=bg.alpha; ctx.translate(w/2 + bg.offX, h/2 + bg.offY); ctx.rotate(bg.rot); ctx.scale(bg.scale, bg.scale);
  ctx.drawImage(bg.img, -bg.img.width/2, -bg.img.height/2); ctx.restore();
}
function drawArchitect(){
  drawBackground();
  // grid
  const {R,stepX,stepY}=gridParams();
  const w=canvas.width/DPR,h=canvas.height/DPR;
  ctx.save(); ctx.translate((w/2 + ORIGIN.x) % stepX, (h/2 + ORIGIN.y) % stepY);
  ctx.lineWidth=0.9; ctx.strokeStyle='#00000018';
  const cols=Math.ceil(w/stepX)+4, rows=Math.ceil(h/stepY)+4;
  for(let r=-2;r<rows;r++){
    for(let c=-2;c<cols;c++){
      const x=c*stepX+(r%2? stepX/2:0), y=r*stepY;
      ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.stroke();
    }
  }
  ctx.restore();

  // drawings
  ctx.lineWidth=+ui.stroke2d.value; ctx.strokeStyle='#111'; ctx.fillStyle='#111';
  sketch.forEach(d=>{
    if(d.type==='seg'){
      ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke();
      if(d.wall>0){
        const nx = d.b.y-d.a.y, ny = -(d.b.x-d.a.x); const L=Math.hypot(nx,ny)||1; const ux=nx/L, uy=ny/L, t=d.wall/2;
        ctx.beginPath(); ctx.moveTo(d.a.x+ux*t,d.a.y+uy*t); ctx.lineTo(d.b.x+ux*t,d.b.y+uy*t); ctx.lineTo(d.b.x-ux*t,d.b.y-uy*t); ctx.lineTo(d.a.x-ux*t,d.a.y-uy*t); ctx.closePath(); ctx.stroke();
      }
    }
    if(d.type==='arc'){ ctx.beginPath(); ctx.arc(d.c.x,d.c.y,d.r,d.a1,d.a2,d.ccw||false); ctx.stroke(); }
    if(d.type==='circ'){ ctx.beginPath(); ctx.arc(d.c.x,d.c.y,d.r,0,Math.PI*2); ctx.stroke(); }
    if(d.type==='dim'){
      ctx.beginPath(); ctx.moveTo(d.ta.x,d.ta.y); ctx.lineTo(d.tb.x,d.tb.y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(d.h1.x,d.h1.y); ctx.lineTo(d.a.x,d.a.y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(d.h2.x,d.h2.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke();
      ctx.fillText(d.text, d.label.x, d.label.y);
    }
    if(d.type==='door'){
      ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke();
      ctx.beginPath(); ctx.arc(d.a.x,d.a.y,d.r,Math.atan2(d.b.y-d.a.y,d.b.x-d.a.x), Math.atan2(d.arc.y-d.a.y,d.arc.x-d.a.x)); ctx.stroke();
    }
    if(d.type==='window'){ ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke(); }
    if(d.type==='label'){ ctx.fillText(d.text, d.p.x, d.p.y); }
  });

  ctx.fillStyle='#222'; ctx.font='12px system-ui';
  ctx.fillText('2D Architect: Walls • Arcs • Dimensions • Doors/Windows • Labels • SVG export', 16, canvas.height/DPR-18);
}

/* ===== Sim Lab: scenarios ===== */
let scale3d=1.1, persp3d=3.0, rot={xy:0,xz:0,yz:0};
ui.resetSim.addEventListener('click', ()=>{ scale3d=1.1; persp3d=3.0; rot={xy:0,xz:0,yz:0}; });

function rot2(a,b,t){const c=Math.cos(t),s=Math.sin(t);return[a*c-b*s,a*s+b*c];}
function proj3(p, pz){ const z=p.z+pz; return {x:p.x/pz*pz/z, y:p.y/pz*pz/z, z:p.z}; }

const scenarios={
  projectile:{
    name:'Projectile Motion',
    controls:`<div class="row"><label>Speed (m/s)</label><input id="sp" type="number" step="0.1" value="20"></div>
              <div class="row"><label>Angle (deg)</label><input id="ang" type="number" step="0.1" value="45"></div>
              <div class="row"><label>Gravity (m/s²)</label><input id="g" type="number" step="0.1" value="9.81"></div>
              <div class="row"><button id="runSim" class="primary">Run</button></div>`,
    steps:(p)=>[
      'We launch with initial speed v at angle θ above horizontal.',
      'Horizontal velocity: vx = v·cosθ; Vertical: vy = v·sinθ.',
      'Time of flight (level ground): T = 2·vy/g.',
      'Range: R = vx·T. Peak height: H = vy²/(2g).',
      `Compute with your inputs: T≈${p.T.toFixed(2)} s, R≈${p.R.toFixed(2)} m, H≈${p.H.toFixed(2)} m.`
    ],
    compute:(inp)=>{
      const v=+inp.sp, th=+inp.ang*Math.PI/180, g=Math.max(0.1,+inp.g);
      const vx=v*Math.cos(th), vy=v*Math.sin(th);
      const T= 2*vy/g, R=vx*T, H=vy*vy/(2*g);
      return {v,th,g,vx,vy,T,R,H};
    },
    draw:(vars)=>{
      // 2D trajectory in X-Y, then show as a thin 3D ribbon for rotation
      const s=12*scale3d, p=persp3d;
      // base axes
      const origin = {x:canvas.width/DPR/6, y:canvas.height/DPR*0.75};
      ctx.strokeStyle='#00000033'; ctx.beginPath(); ctx.moveTo(origin.x,origin.y); ctx.lineTo(origin.x+500,origin.y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(origin.x,origin.y); ctx.lineTo(origin.x,origin.y-300); ctx.stroke();

      // path
      ctx.strokeStyle='#111'; ctx.lineWidth=1.6; ctx.beginPath();
      const N=120; for(let i=0;i<=N;i++){
        const t=vars.T*i/N, x=vars.vx*t, y=vars.vy*t - 0.5*vars.g*t*t;
        const px=origin.x + x*s, py=origin.y - y*s;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      } ctx.stroke();

      // annotations
      ctx.fillStyle='#222'; ctx.font='12px system-ui';
      ctx.fillText(`T≈${vars.T.toFixed(2)} s`, origin.x+5, origin.y-120);
      ctx.fillText(`R≈${vars.R.toFixed(2)} m`, origin.x+vars.R*s-40, origin.y-6);
      ctx.fillText(`H≈${vars.H.toFixed(2)} m`, origin.x+30, origin.y-vars.H*s-6);
    }
  },
  incline:{
    name:'Inclined Plane',
    controls:`<div class="row"><label>Mass (kg)</label><input id="m" type="number" step="0.1" value="5"></div>
              <div class="row"><label>Angle (deg)</label><input id="theta" type="number" step="0.1" value="20"></div>
              <div class="row"><label>μ (friction)</label><input id="mu" type="number" step="0.01" value="0.20"></div>
              <div class="row"><label>g (m/s²)</label><input id="g2" type="number" step="0.1" value="9.81"></div>
              <div class="row"><button id="runSim" class="primary">Run</button></div>`,
    steps:(p)=>[
      'Resolve weight mg into components parallel and perpendicular to plane.',
      'Down-slope: mg·sinθ; Normal: mg·cosθ.',
      'Friction (max) = μ·N = μ·mg·cosθ (opposes motion).',
      `Net along slope: a = g(sinθ − μ cosθ) ⇒ a≈${p.a.toFixed(3)} m/s².`,
      p.a>0 ? 'Block accelerates down the plane.' : (p.a<0 ? 'It accelerates up (requires external pull).' : 'It’s at threshold of motion.')
    ],
    compute:(inp)=>{
      const m=+inp.m, th=+inp.theta*Math.PI/180, mu=Math.max(0,+inp.mu), g=Math.max(0.1,+inp.g2);
      const a = g*(Math.sin(th) - mu*Math.cos(th));
      return {m,th,mu,g,a};
    },
    draw:(vars)=>{
      // simple 2D diagram
      const cx=canvas.width/DPR*0.65, cy=canvas.height/DPR*0.75;
      const L=240, ang=-vars.th; // plane angle
      // plane
      ctx.strokeStyle='#111'; ctx.lineWidth=1.6; ctx.beginPath(); ctx.moveTo(cx-L*Math.cos(ang), cy-L*Math.sin(ang)); ctx.lineTo(cx+L*Math.cos(ang), cy+L*Math.sin(ang)); ctx.stroke();
      // block
      const bx=cx-30*Math.cos(ang), by=cy-30*Math.sin(ang);
      ctx.save(); ctx.translate(bx,by); ctx.rotate(ang); ctx.strokeRect(-20,-14,40,28); ctx.restore();
      // forces
      // weight
      ctx.strokeStyle='#c00'; ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(bx,by+80); ctx.stroke();
      // normal
      const nAng=ang+Math.PI/2; ctx.strokeStyle='#06c'; ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(bx+60*Math.cos(nAng), by+60*Math.sin(nAng)); ctx.stroke();
      // down-slope component arrow
      ctx.strokeStyle='#0a0'; ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(bx+80*Math.cos(ang), by+80*Math.sin(ang)); ctx.stroke();

      ctx.fillStyle='#222'; ctx.font='12px system-ui';
      ctx.fillText(`a≈${vars.a.toFixed(3)} m/s²`, bx+10, by-10);
    }
  },
  circular:{
    name:'Circular Motion',
    controls:`<div class="row"><label>Radius (m)</label><input id="r" type="number" step="0.1" value="5"></div>
              <div class="row"><label>Speed (m/s)</label><input id="v" type="number" step="0.1" value="6"></div>
              <div class="row"><label>g (m/s²)</label><input id="g3" type="number" step="0.1" value="9.81"></div>
              <div class="row"><button id="runSim" class="primary">Run</button></div>`,
    steps:(p)=>[
      'Uniform circular motion: centripetal acceleration ac = v²/r toward center.',
      `ac≈${p.ac.toFixed(3)} m/s². Centripetal force Fc = m·ac (if a mass is attached).`,
      `Period T = 2πr/v ≈ ${p.T.toFixed(2)} s. Frequency f = 1/T.`,
      'Vector diagram shows velocity tangent and acceleration radial.'
    ],
    compute:(inp)=>{
      const r=Math.max(0.01,+inp.r), v=Math.max(0,+inp.v);
      const ac=v*v/r, T = (2*Math.PI*r)/v;
      return {r,v,ac,T};
    },
    draw:(vars)=>{
      const cx=canvas.width/DPR*0.5, cy=canvas.height/DPR*0.55, s=18*scale3d;
      // circle
      ctx.strokeStyle='#111'; ctx.lineWidth=1.6; ctx.beginPath(); ctx.arc(cx,cy,vars.r*s,0,2*Math.PI); ctx.stroke();
      // marker
      const a=0.6; const px=cx+vars.r*s*Math.cos(a), py=cy+vars.r*s*Math.sin(a);
      // velocity (tangent)
      ctx.strokeStyle='#06c'; ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(px-80*Math.sin(a), py+80*Math.cos(a)); ctx.stroke();
      // acceleration (inward)
      ctx.strokeStyle='#c00'; ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(cx,cy); ctx.stroke();
      ctx.fillStyle='#222'; ctx.font='12px system-ui'; ctx.fillText(`ac≈${vars.ac.toFixed(2)} m/s², T≈${vars.T.toFixed(2)} s`, cx-80, cy+vars.r*s+20);
    }
  },
  vectors:{
    name:'Vector Addition',
    controls:`<div class="row"><label>v1 (mag,deg)</label><input id="v1m" type="number" step="0.1" value="5"><input id="v1a" type="number" step="0.1" value="30"></div>
              <div class="row"><label>v2 (mag,deg)</label><input id="v2m" type="number" step="0.1" value="4"><input id="v2a" type="number" step="0.1" value="120"></div>
              <div class="row"><button id="runSim" class="primary">Run</button></div>`,
    steps:(p)=>[
      'Break each vector into x/y components.',
      `v1x=${p.v1x.toFixed(2)}, v1y=${p.v1y.toFixed(2)}; v2x=${p.v2x.toFixed(2)}, v2y=${p.v2y.toFixed(2)}.`,
      `Sum: Rx=${p.Rx.toFixed(2)}, Ry=${p.Ry.toFixed(2)}.`,
      `Resultant magnitude R≈${p.R.toFixed(2)} at angle ≈${(p.Ra*180/Math.PI).toFixed(1)}°.`
    ],
    compute:(inp)=>{
      const v1m=+inp.v1m, v1a=+inp.v1a*Math.PI/180, v2m=+inp.v2m, v2a=+inp.v2a*Math.PI/180;
      const v1x=v1m*Math.cos(v1a), v1y=v1m*Math.sin(v1a);
      const v2x=v2m*Math.cos(v2a), v2y=v2m*Math.sin(v2a);
      const Rx=v1x+v2x, Ry=v1y+v2y, R=Math.hypot(Rx,Ry), Ra=Math.atan2(Ry,Rx);
      return {v1x,v1y,v2x,v2y,Rx,Ry,R,Ra};
    },
    draw:(vars)=>{
      const O={x:canvas.width/DPR*0.25,y:canvas.height/DPR*0.7}, s=25*scale3d;
      function end(p){ return {x:O.x+p.mag*s*Math.cos(p.ang), y:O.y-p.mag*s*Math.sin(p.ang)}; }
      // v1, v2, resultant
      // draw axes
      ctx.strokeStyle='#00000022'; ctx.beginPath(); ctx.moveTo(O.x-40,O.y); ctx.lineTo(O.x+400,O.y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(O.x,O.y+120); ctx.lineTo(O.x,O.y-220); ctx.stroke();

      // v1
      let e1=end({mag:Math.hypot(vars.v1x,vars.v1y), ang:Math.atan2(vars.v1y,vars.v1x)});
      ctx.strokeStyle='#06c'; ctx.beginPath(); ctx.moveTo(O.x,O.y); ctx.lineTo(e1.x,e1.y); ctx.stroke();
      // v2 (head-to-tail)
      let e2h=e1, e2={x:e2h.x+vars.v2x*s, y:e2h.y-vars.v2y*s};
      ctx.strokeStyle='#0a0'; ctx.beginPath(); ctx.moveTo(e2h.x,e2h.y); ctx.lineTo(e2.x,e2.y); ctx.stroke();
      // resultant
      let R={x:O.x+vars.Rx*s,y:O.y-vars.Ry*s};
      ctx.strokeStyle='#c00'; ctx.beginPath(); ctx.moveTo(O.x,O.y); ctx.lineTo(R.x,R.y); ctx.stroke();

      ctx.fillStyle='#222'; ctx.font='12px system-ui';
      ctx.fillText(`R≈${vars.R.toFixed(2)} @ ${(vars.Ra*180/Math.PI).toFixed(1)}°`, R.x+6, R.y-6);
    }
  },
  quadratic:{
    name:'Quadratic Grapher',
    controls:`<div class="row"><label>y = ax² + bx + c</label><input id="qa" type="number" step="0.1" value="1"><input id="qb" type="number" step="0.1" value="0"><input id="qc" type="number" step="0.1" value="0"></div>
              <div class="row"><button id="runSim" class="primary">Graph</button></div>`,
    steps:(p)=>[
      'A quadratic y=ax²+bx+c is a parabola.',
      `Vertex: x_v = −b/(2a), y_v = f(x_v).`,
      `Discriminant Δ = b²−4ac → roots when Δ ≥ 0.`,
      `With your a,b,c → vertex ≈ (${p.xv.toFixed(2)}, ${p.yv.toFixed(2)}), Δ ≈ ${p.D.toFixed(2)}.`,
      p.D>=0 ? `Roots: x≈${p.r1.toFixed(2)}, ${p.r2.toFixed(2)}` : 'No real roots (parabola doesn’t cross x-axis).'
    ],
    compute:(inp)=>{
      const a=+inp.qa, b=+inp.qb, c=+inp.qc;
      const xv = -b/(2*a||1e-9), yv = a*xv*xv + b*xv + c;
      const D = b*b - 4*a*c;
      let r1=NaN, r2=NaN; if(D>=0){ r1=(-b-Math.sqrt(D))/(2*a||1e-9); r2=(-b+Math.sqrt(D))/(2*a||1e-9); }
      return {a,b,c,xv,yv,D,r1,r2};
    },
    draw:(vars)=>{
      // plot with simple axes
      const w=canvas.width/DPR,h=canvas.height/DPR;
      const cx=w*0.65, cy=h*0.6, s=40*scale3d;
      ctx.strokeStyle='#00000022'; ctx.beginPath(); ctx.moveTo(cx-300,cy); ctx.lineTo(cx+300,cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx,cy+200); ctx.lineTo(cx,cy-200); ctx.stroke();

      ctx.strokeStyle='#111'; ctx.beginPath();
      for(let i=-300;i<=300;i++){
        const x=i/ s, y=vars.a*x*x + vars.b*x + vars.c;
        const px=cx+i, py=cy - y*s;
        if(i===-300) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      } ctx.stroke();

      ctx.fillStyle='#222'; ctx.font='12px system-ui';
      ctx.fillText(`vertex ≈ (${vars.xv.toFixed(2)}, ${vars.yv.toFixed(2)})`, cx-120, cy-170);
      if(!isNaN(vars.r1)){ ctx.fillText(`roots ≈ ${vars.r1.toFixed(2)}, ${vars.r2.toFixed(2)}`, cx-120, cy-150); }
    }
  }
};

function mountScenarioUI(){
  const sc = scenarios[ui.scenario.value];
  ui.controls.innerHTML = sc.controls;
  const runBtn = document.getElementById('runSim');
  if(runBtn) runBtn.onclick = ()=>{ stepIndex=0; runScenario(); };
  runScenario(true);
}
ui.scenario.addEventListener('change', ()=>{ stepIndex=0; mountScenarioUI(); });
ui.simMode.addEventListener('change', ()=>{ stepIndex=0; runScenario(); });
mountScenarioUI();

let stepIndex=0, activeVars=null;
function runScenario(skipCompute){
  const sc = scenarios[ui.scenario.value];
  // collect inputs from controls div by IDs used in sc.controls
  const inputs={}; ui.controls.querySelectorAll('input').forEach(el=>inputs[el.id]=+el.value);
  activeVars = sc.compute(inputs);
  const mode = ui.simMode.value;
  const steps = sc.steps(activeVars);
  if(mode==='answer') stepIndex = steps.length-1;
  coach.innerHTML = renderCoach(steps, stepIndex, sc.name, mode);
}
function renderCoach(steps, i, title, mode){
  return `
    <div><b>${title} — ${mode==='learn'?'Learn':'Answer'}</b></div>
    <div style="margin:6px 0 10px;color:#333">${steps[i]||'Set inputs and press Run'}</div>
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button ${i<=0?'disabled':''} onclick="window.__prevStep()">Prev</button>
      <button ${i>=steps.length-1?'disabled':''} onclick="window.__nextStep()">Next</button>
      <button onclick="window.__showAnswer()">Show Answer</button>
    </div>
  `;
}
window.__prevStep = ()=>{ if(stepIndex>0){ stepIndex--; const sc=scenarios[ui.scenario.value]; coach.innerHTML=renderCoach(sc.steps(activeVars),stepIndex,sc.name,ui.simMode.value); } };
window.__nextStep = ()=>{ const sc=scenarios[ui.scenario.value]; const steps=sc.steps(activeVars); if(stepIndex<steps.length-1){ stepIndex++; coach.innerHTML=renderCoach(steps,stepIndex,sc.name,ui.simMode.value); } };
window.__showAnswer = ()=>{ const sc=scenarios[ui.scenario.value]; const steps=sc.steps(activeVars); stepIndex=steps.length-1; coach.innerHTML=renderCoach(steps,stepIndex,sc.name,ui.simMode.value); };

/* ===== Shared render loop ===== */
let draggingSim=false, lastX=0,lastY=0;
addEventListener('mousedown', e=>{ if(ui.mode.value==='simlab'){ draggingSim=true; lastX=e.clientX; lastY=e.clientY; } });
addEventListener('mousemove', e=>{
  if(ui.mode.value==='simlab' && draggingSim){ rot.xy += (e.clientX-lastX)*0.005; rot.xz += (e.clientY-lastY)*0.005; lastX=e.clientX; lastY=e.clientY; }
});
addEventListener('mouseup', ()=>{ draggingSim=false; });

function drawSim(){
  const sc = scenarios[ui.scenario.value];
  sc.draw(activeVars);
  ctx.fillStyle='#222'; ctx.font='12px system-ui';
  ctx.fillText('Sim Lab: Learn → step through; Answer → quick results. Adjust inputs, then Run.', 16, canvas.height/DPR-18);
}

let last=0;
function render(t, force=false){
  if(!force && t-last<14){ requestAnimationFrame(render); return; }
  last=t;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round';
  if(ui.mode.value==='architect2d'){ drawArchitect(); }
  else { drawSim(); }
  ctx.restore();
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

// initial coach text
coach.innerHTML = `<b>Welcome</b><br>Architect: draft plans with walls, dimensions, doors/windows.<br>Sim Lab: pick a scenario, choose <i>Learn</i> or <i>Answer</i>, then <b>Run</b>.`;
} // end startApp
</script>
</body>
</html>
