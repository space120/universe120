<script>
document.getElementById('year').textContent = new Date().getFullYear();

/** Canvas + DPR scaling **/
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: true });
let DPR = Math.min(devicePixelRatio || 1, 2); // cap for perf

function resize(){
  const w = innerWidth, h = innerHeight;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.round(w * DPR);
  canvas.height = Math.round(h * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize); resize();

/** UI **/
const $ = id => document.getElementById(id);
const ui = {
  preset2d: $('preset2d'), preset3d: $('preset3d'), preset4d: $('preset4d'),
  reset: $('resetView'), help: $('toggleHelp'),
  mode: $('mode'), scale: $('scale'), persp: $('persp'), stroke: $('stroke'), anim: $('anim'),
  rXY: $('rXY'), rXZ: $('rXZ'), rYZ: $('rYZ'), rXW: $('rXW'), rYW: $('rYW'), rZW: $('rZW'),
  rotBlock: $('rotBlock'),
  drawEnabled: $('drawEnabled'), tool: $('tool'), brush: $('brush'), color: $('color'),
  undoBtn: $('undoBtn'), clearBtn: $('clearBtn'), saveBtn: $('saveBtn')
};
ui.mode.addEventListener('change', ()=> ui.rotBlock.style.display = (ui.mode.value==='grid2d') ? 'none' : 'block');

/** Interaction & state **/
let dragging=false, lastX=0,lastY=0;
let userRot = {xy:0,xz:0,yz:0,xw:0,yw:0,zw:0};
let targetRot = {...userRot}; // for easing
let pan = {x:0,y:0};
let zoom = 1;
let spacePan = false; // hold Space to pan in 2D even when Draw is on

// Touch pinch zoom
let touchMode = { active:false, startDist:0, startZoom:1, lastMid:null };
function dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
function mid(a,b){ return {x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2}; }

/** Draw layer (2D only) **/
const shapes = [];
let lineStart = null;

/** Helpers **/
function rot2(a,b,theta){ const c=Math.cos(theta), s=Math.sin(theta); return [a*c - b*s, a*s + b*c]; }
function project3to2(p3, persp){ const z = p3.z + persp; return { x: p3.x/persp * persp/z, y: p3.y/persp * persp/z, z: p3.z }; }
function drawLine(x1,y1,x2,y2, alpha=1){ ctx.globalAlpha = alpha; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); ctx.globalAlpha = 1; }
function getInk(){ return getComputedStyle(document.documentElement).getPropertyValue('--ink').trim() || '#111'; }
function getStroke(){ return getInk(); }

function getGridParams(){
  const R = 26 * zoom;
  const stepX = R;
  const stepY = R*Math.sqrt(3)/2;
  return {R, stepX, stepY};
}
function snapToGrid(clientX, clientY){
  const {stepX, stepY} = getGridParams();
  const x = clientX - (pan.x % stepX);
  const y = clientY - (pan.y % stepY);
  let best=[x,y], bestD=1e9;
  for(let dr=-2; dr<=2; dr++){
    for(let dc=-2; dc<=2; dc++){
      const rr = Math.round(y/stepY)+dr;
      const cc = Math.round((x - (rr%2? stepX/2:0))/stepX)+dc;
      const gx = cc*stepX + (rr%2? stepX/2:0);
      const gy = rr*stepY;
      const d2 = (gx-x)*(gx-x)+(gy-y)*(gy-y);
      if(d2<bestD){bestD=d2; best=[gx,gy];}
    }
  }
  return {x: best[0] + (pan.x % stepX), y: best[1] + (pan.y % stepY)};
}

/** 2D Grid **/
function drawShapes(){
  shapes.forEach(s=>{
    ctx.save();
    ctx.lineWidth = s.size || +ui.stroke.value;
    ctx.strokeStyle = s.color || getInk();
    ctx.fillStyle = s.color || getInk();
    if(s.type==='dot'){
      ctx.beginPath(); ctx.arc(s.x, s.y, (s.size||8)/2, 0, Math.PI*2); ctx.fill();
    } else if(s.type==='bubble'){
      ctx.beginPath(); ctx.arc(s.x, s.y, s.r || 18, 0, Math.PI*2); ctx.stroke();
    } else if(s.type==='line'){
      drawLine(s.x1, s.y1, s.x2, s.y2, 1);
    }
    ctx.restore();
  });
}
function drawBubbleGrid(){
  const {R, stepX, stepY} = getGridParams();
  const w = canvas.width/DPR, h = canvas.height/DPR;
  const cols = Math.ceil(w/stepX)+4, rows = Math.ceil(h/stepY)+4;

  ctx.save();
  ctx.translate(pan.x % stepX, pan.y % stepY);
  ctx.lineWidth = +ui.stroke.value;
  ctx.strokeStyle = getStroke();

  for(let r= -2; r<rows; r++){
    for(let c= -2; c<cols; c++){
      const x = c*stepX + (r%2? stepX/2:0), y = r*stepY;
      ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.stroke();
      ctx.globalAlpha=0.18;
      [[x+stepX,y],[x-stepX,y],[x+stepX/2,y+stepY],[x-stepX/2,y+stepY],[x+stepX/2,y-stepY],[x-stepX/2,y-stepY]]
        .forEach(([nx,ny])=>{ ctx.beginPath(); ctx.arc(nx,ny,R,0,Math.PI*2); ctx.stroke(); });
      ctx.globalAlpha=1;
    }
  }
  ctx.restore();
  drawShapes();
  ctx.fillStyle=getInk(); ctx.font='14px system-ui';
  ctx.fillText(spacePan ? 'Space = Pan (2D)' : 'Tip: Hold Space to Pan in 2D', 20, canvas.height/DPR - 20);
}

/** 3D & 4D data **/
const cube = (()=>{ const v=[]; for(let x of [-1,1]) for(let y of [-1,1]) for(let z of [-1,1]) v.push({x,y,z}); return v; })();
const cubeE = (()=>{ const e=[]; for(let i=0;i<8;i++){ for(let j=i+1;j<8;j++){ const a=cube[i], b=cube[j]; const d=(a.x!==b.x)+(a.y!==b.y)+(a.z!==b.z); if(d===1) e.push([i,j]); } } return e; })();
const tess = (()=>{ const v=[]; for(let x of [-1,1]) for(let y of [-1,1]) for(let z of [-1,1]) for(let w of [-1,1]) v.push({x,y,z,w}); return v; })();
const tessE = (()=>{ const e=[]; for(let i=0;i<16;i++){ for(let j=i+1;j<16;j++){ const a=tess[i], b=tess[j]; const d=(a.x!==b.x)+(a.y!==b.y)+(a.z!==b.z)+(a.w!==b.w); if(d===1) e.push([i,j]); } } return e; })();

/** Renderers **/
function label(text){ ctx.fillStyle=getInk(); ctx.font='14px system-ui'; ctx.fillText(text, 20, canvas.height/DPR - 20); }

function drawCube(time){
  ctx.lineWidth=+ui.stroke.value; ctx.strokeStyle=getStroke();
  // ease towards target rotation for smoothness
  userRot.xy += (targetRot.xy - userRot.xy)*0.15;
  userRot.xz += (targetRot.xz - userRot.xz)*0.15;
  userRot.yz += (targetRot.yz - userRot.yz)*0.15;

  const s = +ui.scale.value * 160, persp = +ui.persp.value;
  const ax= (+ui.rXY.value + userRot.xy) % (Math.PI*2);
  const ay= (+ui.rXZ.value + userRot.xz) % (Math.PI*2);
  const az= (+ui.rYZ.value + userRot.yz) % (Math.PI*2);

  const pts2 = cube.map(p=>{
    let [x,y] = rot2(p.x,p.y, ax);
    let [y2,z] = rot2(y,p.z, ay);
    let [x2,z2] = rot2(x,z, az);
    const p2 = project3to2({x:x2,y:y2,z:z2}, persp);
    return {x: canvas.width/DPR/2 + p2.x*s, y: canvas.height/DPR/2 + p2.y*s, z:p2.z};
  });

  cubeE.slice().sort((a,b)=>{
    const za=(pts2[a[0]].z+pts2[a[1]].z), zb=(pts2[b[0]].z+pts2[b[1]].z); return za - zb;
  }).forEach(([i,j])=>{
    const a=pts2[i], b=pts2[j];
    const alpha = 0.4 + 0.6 * ((a.z+b.z)/2 + 2)/(4);
    drawLine(a.x,a.y,b.x,b.y,alpha);
  });
  label('3D Cube — drag to rotate; wheel/pinch to zoom');
}

function drawTesseract(time){
  ctx.lineWidth = +ui.stroke.value;

  // easing
  userRot.xy += (targetRot.xy - userRot.xy)*0.15;
  userRot.xz += (targetRot.xz - userRot.xz)*0.15;
  userRot.yz += (targetRot.yz - userRot.yz)*0.15;
  userRot.xw += (targetRot.xw - userRot.xw)*0.15;
  userRot.yw += (targetRot.yw - userRot.yw)*0.15;
  userRot.zw += (targetRot.zw - userRot.zw)*0.15;

  const s = +ui.scale.value * 160, persp3 = +ui.persp.value, persp4 = 2.5;
  const t = ui.anim.checked ? time*0.0007 : 0;
  const aXY= +ui.rXY.value + userRot.xy + t*0.6;
  const aXZ= +ui.rXZ.value + userRot.xz + t*0.45;
  const aYZ= +ui.rYZ.value + userRot.yz + t*0.25;
  const aXW= +ui.rXW.value + userRot.xw + t*0.32;
  const aYW= +ui.rYW.value + userRot.yw + t*0.20;
  const aZW= +ui.rZW.value + userRot.zw + t*0.15;

  const pts2 = tess.map(p=>{
    let x=p.x, y=p.y, z=p.z, w=p.w;
    [x,y] = rot2(x,y,aXY); [x,z] = rot2(x,z,aXZ); [y,z] = rot2(y,z,aYZ);
    [x,w] = rot2(x,w,aXW); [y,w] = rot2(y,w,aYW); [z,w] = rot2(z,w,aZW);
    const wFactor = persp4/(persp4 - w); const x3 = x*wFactor, y3 = y*wFactor, z3 = z*wFactor;
    const p2 = project3to2({x:x3,y:y3,z:z3}, persp3);
    return {x: canvas.width/DPR/2 + p2.x*s, y: canvas.height/DPR/2 + p2.y*s, z: z3};
  });

  tessE.slice().sort((a,b)=>{
    const za=(pts2[a[0]].z+pts2[a[1]].z), zb=(pts2[b[0]].z+pts2[b[1]].z); return za - zb;
  }).forEach(([i,j])=>{
    const a=pts2[i], b=pts2[j];
    const d = ((a.z+b.z)/2 + 4)/8;
    ctx.strokeStyle = `hsla(${220 + 160*d}, 70%, ${30+35*d}%, ${0.45+0.45*d})`;
    drawLine(a.x,a.y,b.x,b.y, 0.6+0.4*d);
  });
  label('4D Tesseract — use XW/YW/ZW; wheel/pinch to zoom');
}

/** Mouse / touch / keyboard **/
canvas.addEventListener('mousedown',e=>{
  dragging=true; lastX=e.clientX; lastY=e.clientY;
  if(ui.mode.value==='grid2d' && ui.drawEnabled.checked && !spacePan){
    const pos = e.shiftKey ? snapToGrid(e.clientX, e.clientY) : {x:e.clientX, y:e.clientY};
    const color = ui.color.value; const size = +ui.brush.value;
    if(ui.tool.value==='dot'){ shapes.push({type:'dot', x:pos.x, y:pos.y, color, size}); }
    else if(ui.tool.value==='bubble'){ shapes.push({type:'bubble', x:pos.x, y:pos.y, r:size, color, size}); }
    else if(ui.tool.value==='line'){ lineStart = pos; }
  }
});
addEventListener('mouseup',e=>{
  if(ui.mode.value==='grid2d' && ui.drawEnabled.checked && ui.tool.value==='line' && lineStart && !spacePan){
    const pos = e.shiftKey ? snapToGrid(e.clientX, e.clientY) : {x:e.clientX, y:e.clientY};
    shapes.push({type:'line', x1:lineStart.x, y1:lineStart.y, x2:pos.x, y2:pos.y, color:ui.color.value, size:+ui.brush.value});
    lineStart=null;
  }
  dragging=false;
});
addEventListener('mousemove',e=>{
  if(!dragging) return;
  const dx = e.clientX-lastX, dy=e.clientY-lastY;
  lastX=e.clientX; lastY=e.clientY;
  if(ui.mode.value==='grid2d' && (spacePan || !ui.drawEnabled.checked)){ pan.x+=dx; pan.y+=dy; }
  else { targetRot.xy += dx*0.005; targetRot.xz += dy*0.005; }
});
canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const factor = Math.exp(-e.deltaY*0.001);
  if(ui.mode.value==='grid2d') zoom = Math.max(0.2, Math.min(5, zoom*factor));
  else ui.scale.value = (+ui.scale.value * factor).toFixed(2);
},{passive:false});

// touch
canvas.addEventListener('touchstart', (e)=>{
  if(e.touches.length===2){
    touchMode.active=true;
    touchMode.startDist = dist(e.touches[0], e.touches[1]);
    touchMode.startZoom = ui.mode.value==='grid2d' ? zoom : +ui.scale.value;
    touchMode.lastMid = mid(e.touches[0], e.touches[1]);
  } else {
    dragging = true;
    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
  }
},{passive:false});
canvas.addEventListener('touchmove', (e)=>{
  if(touchMode.active && e.touches.length===2){
    const d = dist(e.touches[0], e.touches[1]);
    const f = d / (touchMode.startDist || d);
    if(ui.mode.value==='grid2d') zoom = Math.max(0.2, Math.min(5, touchMode.startZoom * f));
    else ui.scale.value = Math.max(0.3, Math.min(2.5, touchMode.startZoom * f)).toFixed(2);
  } else if(dragging){
    const dx = e.touches[0].clientX - lastX;
    const dy = e.touches[0].clientY - lastY;
    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
    if(ui.mode.value==='grid2d' && (spacePan || !ui.drawEnabled.checked)) { pan.x += dx; pan.y += dy; }
    else { targetRot.xy += dx*0.005; targetRot.xz += dy*0.005; }
  }
},{passive:false});
addEventListener('touchend', ()=>{ dragging=false; touchMode.active=false; }, {passive:true});

// keyboard
addEventListener('keydown', (e)=>{ if(e.code==='Space'){ spacePan=true; } });
addEventListener('keyup',   (e)=>{ if(e.code==='Space'){ spacePan=false; } });

/** Undo / Clear / Save **/
ui.undoBtn.addEventListener('click', ()=> shapes.pop() );
ui.clearBtn.addEventListener('click', ()=> shapes.length=0 );
ui.saveBtn.addEventListener('click', ()=>{
  const link=document.createElement('a');
  link.download='universe120.png';
  link.href=canvas.toDataURL('image/png');
  link.click();
});

/** Presets + Reset **/
ui.reset.addEventListener('click', ()=>{
  pan = {x:0,y:0}; zoom = 1;
  targetRot = {xy:0,xz:0,yz:0,xw:0,yw:0,zw:0};
  userRot = {...targetRot};
  ui.scale.value = 1.1; ui.persp.value = 3.0; ui.stroke.value = 1.3;
});

ui.preset2d.addEventListener('click', ()=>{
  ui.mode.value='grid2d'; pan={x:0,y:0}; zoom=1; ui.stroke.value=1.2;
});
ui.preset3d.addEventListener('click', ()=>{
  ui.mode.value='cube3d'; ui.scale.value=1.2; ui.persp.value=3.2; targetRot={xy:0.2,xz:0.6,yz:0.1,xw:0,yw:0,zw:0};
});
ui.preset4d.addEventListener('click', ()=>{
  ui.mode.value='tesseract4d'; ui.scale.value=1.1; ui.persp.value=3.0;
  targetRot={xy:0.2,xz:0.5,yz:0.1,xw:0.4,yw:0.6,zw:0.8};
});

/** Main render loop (frame cap for battery) **/
let last = 0;
function render(time){
  // cap ~60fps
  if(time - last < 14){ requestAnimationFrame(render); return; }
  last = time;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round';
  if(ui.mode.value==='grid2d') drawBubbleGrid();
  else if(ui.mode.value==='cube3d') drawCube(time);
  else drawTesseract(time);
  ctx.restore();
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
