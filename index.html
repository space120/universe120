<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Universe120 — 2D Architect + 3D Tutor</title>
<style>
:root{--bg:#f7f7fb;--card:#ffffffcc;--ink:#111;--muted:#666;--border:#e7e7ee;--brand:#3538ff}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
.site-header,.site-footer{position:fixed;left:0;right:0;display:flex;align-items:center;gap:16px;background:#fff8;backdrop-filter:saturate(1.8) blur(8px);border-bottom:1px solid var(--border);z-index:20}
.site-header{top:0;padding:10px 16px}
.site-footer{bottom:0;justify-content:center;border-top:1px solid var(--border);border-bottom:none;padding:8px 16px}
.brand{font-weight:800}
#ui.panel{position:fixed;left:16px;top:64px;z-index:15;background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px 14px;max-width:420px;box-shadow:0 6px 22px rgba(0,0,0,.07)}
#ui h1{margin:.25rem 0 .5rem;font-size:18px}
.row{display:flex;gap:8px;align-items:center;margin:.35rem 0}
label{font-size:12px;color:#444;min-width:120px}
input[type=range]{flex:1}
select,input[type=checkbox],input[type=number],input[type=text]{font-size:13px}
fieldset{border:1px dashed var(--border);border-radius:10px;padding:8px 10px;margin:.5rem 0 0}
fieldset legend{font-size:12px;color:#333;padding:0 6px}
button{appearance:none;border:1px solid var(--border);background:#fff;border-radius:10px;padding:8px 12px;font-size:13px;cursor:pointer}
button:hover{background:#f6f6ff}
button.primary{background:#3538ff;color:#fff;border-color:#3538ff}
.kbd{background:#eee;border:1px solid #ccc;border-bottom-color:#bbb;border-radius:4px;padding:0 4px;font-family:ui-monospace,Menlo,Consolas,monospace}
#canvas{display:block;width:100vw;height:100vh}
.overlay{position:fixed;right:16px;top:64px;z-index:16;background:var(--card);border:1px solid var(--border);border-radius:12px;padding:10px 12px;max-width:420px;box-shadow:0 6px 22px rgba(0,0,0,.07);font-size:13px}
@media (max-width: 640px){
  #ui.panel { max-width: 92vw; left: 4vw; }
  .row button, .row select, .row input[type=range], .row input[type=number], .row input[type=text] { min-height: 40px; }
}
/* Password gate */
#gate{position:fixed;inset:0;background:#0a0a0f;color:#eee;display:flex;align-items:center;justify-content:center;z-index:9999}
#gate .box{width:min(90vw,440px);background:#14141b;border:1px solid #2a2a35;border-radius:14px;padding:22px;box-shadow:0 10px 40px rgba(0,0,0,.35);text-align:center}
#gate input{width:100%;padding:12px;border-radius:10px;border:1px solid #39394a;background:#0e0e15;color:#eaeaf2}
#gate button{width:100%;margin-top:10px;background:#3538ff;color:#fff;border:0;padding:12px;border-radius:10px;font-size:15px}
</style>
</head>
<body>
<!-- ====== PASSWORD GATE ====== -->
<div id="gate" aria-modal="true">
  <div class="box">
    <h2>Universe120 — Private Build</h2>
    <p>Enter access key to view.</p>
    <input id="gateKey" type="password" placeholder="••••••">
    <button id="gateBtn">Enter</button>
    <small>Tip: set <b>ACCESS_KEY</b> in the code to change/disable.</small>
  </div>
</div>

<header class="site-header">
  <div class="brand">Universe120 <span style="font-size:12px;border:1px solid var(--border);border-radius:999px;padding:2px 8px;background:#fff">2D Architect + 3D Tutor</span></div>
</header>

<aside id="ui" class="panel" hidden>
  <h1>Toolkit</h1>

  <div class="row">
    <label for="mode">Mode</label>
    <select id="mode">
      <option value="architect2d" selected>2D Architect</option>
      <option value="tutor3d">3D Tutor</option>
    </select>
  </div>

  <!-- 2D Architect -->
  <fieldset id="arch2dBlock">
    <legend>2D Architect</legend>

    <div class="row"><label>Tool</label>
      <select id="tool2d">
        <option value="segment" selected>Segment</option>
        <option value="poly">Polyline</option>
        <option value="arc">Arc (two clicks)</option>
        <option value="circle">Circle (grid radius)</option>
        <option value="erase">Erase</option>
      </select>
    </div>

    <div class="row"><label>Snap</label>
      <select id="snap2d">
        <option value="intersections" selected>Intersections</option>
        <option value="centers">Circle Centers</option>
        <option value="midpoints">Midpoints</option>
        <option value="free">Free</option>
      </select>
    </div>

    <div class="row"><label>Angle Lock</label>
      <select id="lockAngle">
        <option value="off" selected>Off</option>
        <option value="ortho">0/90°</option>
        <option value="thirty">30/60/90°</option>
        <option value="fortyfive">45/90°</option>
      </select>
    </div>

    <div class="row"><label>Wall (px)</label><input id="wallThick" type="number" min="0" max="50" step="1" value="8"></div>
    <div class="row"><label>Stroke</label><input id="stroke2d" type="range" min="0.6" max="3" step="0.1" value="1.4"></div>

    <div class="row"><label>View</label>
      <span><input type="checkbox" id="lockView" checked> Lock View</span>
      <button id="recenter2d" type="button">Recenter</button>
      <button id="zoomReset2d" type="button">Reset Zoom</button>
    </div>

    <div class="row"><button id="undo2d">Undo</button><button id="clear2d">Clear</button><button id="exportSvg" class="primary">Export SVG</button></div>

    <div class="row"><label>Background</label>
      <input id="bgUpload" type="file" accept="image/*">
    </div>
    <div class="row"><label>BG Opacity</label><input id="bgAlpha" type="range" min="0" max="1" step="0.01" value="0.5"></div>
    <div class="row"><label>BG Scale</label><input id="bgScale" type="range" min="0.1" max="4" step="0.01" value="1"></div>
    <div class="row"><label>BG Rotate</label><input id="bgRot" type="range" min="-180" max="180" step="1" value="0"></div>
    <div class="row"><label>BG Offset</label><input id="bgOffX" type="number" value="0" style="width:80px"> <input id="bgOffY" type="number" value="0" style="width:80px"></div>

    <div class="row"><label>Calibrate</label>
      <button id="calibStart">Pick 2 pts</button>
      <input id="calibSteps" type="number" min="1" max="50" step="1" value="4" title="Grid steps between picks" style="width:80px">
    </div>

    <p style="font-size:11px;color:#666">Tips: <span class="kbd">Shift</span> = stronger snap • Double-click ends a polyline • View is locked so you won’t “lose” your plan while zooming</p>
  </fieldset>

  <!-- 3D Tutor -->
  <fieldset id="tutor3dBlock" style="display:none">
    <legend>3D Tutor</legend>

    <div class="row"><label>Mode</label>
      <select id="tutorMode">
        <option value="learn" selected>Learn (guided)</option>
        <option value="answer">Answer (quick)</option>
      </select>
    </div>

    <div class="row"><label>Problem</label>
      <select id="problem">
        <option value="pythag">Pythagorean (hypotenuse)</option>
        <!-- we’ll add more later -->
      </select>
    </div>

    <div class="row" id="pyInputs">
      <label>a, b</label>
      <input id="legA" type="number" min="0" step="0.01" value="3" style="width:90px">
      <input id="legB" type="number" min="0" step="0.01" value="4" style="width:90px">
      <button id="runProblem" class="primary">Run</button>
    </div>

    <div class="row"><label>3D View</label>
      <span><button id="reset3d">Reset</button></span>
    </div>
    <p style="font-size:11px;color:#666">Drag to rotate • Wheel to zoom. In “Learn” we reveal each step instead of dumping the answer.</p>
  </fieldset>
</aside>

<div id="coach" class="overlay" hidden></div>

<canvas id="canvas" hidden></canvas>

<footer class="site-footer">
  <small>© <span id="year"></span> Universe120 • Learn by building</small>
</footer>

<script>
/* ===== CONFIG ===== */
const ACCESS_KEY = '120beta'; // set '' to disable the gate
/* ================== */
document.getElementById('year').textContent = new Date().getFullYear();

/* Gate */
const gate = document.getElementById('gate');
const gateBtn = document.getElementById('gateBtn');
const gateKey = document.getElementById('gateKey');
function openSite(){ gate.remove(); document.getElementById('ui').hidden=false; document.getElementById('canvas').hidden=false; document.getElementById('coach').hidden=false; startApp(); }
function tryGate(){ if(ACCESS_KEY==='' || gateKey.value===ACCESS_KEY) openSite(); else alert('Incorrect key'); }
gateBtn.addEventListener('click', tryGate);
gateKey.addEventListener('keydown', e=>{ if(e.key==='Enter') tryGate(); });
if(ACCESS_KEY==='') openSite();

/* ===== APP ===== */
function startApp(){
const canvas = document.getElementById('canvas');
const coach = document.getElementById('coach');
const ctx = canvas.getContext('2d',{alpha:true});
let DPR = Math.min(devicePixelRatio||1,2);
function resize(){ const w=innerWidth,h=innerHeight; canvas.style.width=w+'px'; canvas.style.height=h+'px'; canvas.width=Math.round(w*DPR); canvas.height=Math.round(h*DPR); ctx.setTransform(DPR,0,0,DPR,0,0); }
addEventListener('resize',resize); resize();

const $=id=>document.getElementById(id);
const ui={
  mode:$('mode'),
  // 2D
  arch2dBlock:$('arch2dBlock'), tool2d:$('tool2d'), snap2d:$('snap2d'), lockAngle:$('lockAngle'),
  wallThick:$('wallThick'), stroke2d:$('stroke2d'),
  lockView:$('lockView'), recenter2d:$('recenter2d'), zoomReset2d:$('zoomReset2d'),
  undo2d:$('undo2d'), clear2d:$('clear2d'), exportSvg:$('exportSvg'),
  bgUpload:$('bgUpload'), bgAlpha:$('bgAlpha'), bgScale:$('bgScale'), bgRot:$('bgRot'), bgOffX:$('bgOffX'), bgOffY:$('bgOffY'),
  calibStart:$('calibStart'), calibSteps:$('calibSteps'),
  // 3D
  tutor3dBlock:$('tutor3dBlock'), tutorMode:$('tutorMode'), problem:$('problem'),
  legA:$('legA'), legB:$('legB'), runProblem:$('runProblem'), reset3d:$('reset3d')
};

ui.mode.addEventListener('change', ()=>{
  ui.arch2dBlock.style.display = ui.mode.value==='architect2d' ? '' : 'none';
  ui.tutor3dBlock.style.display = ui.mode.value==='tutor3d' ? '' : 'none';
  if(ui.mode.value==='tutor3d') stepIndex=0;
  render(0,true);
});

/* ===== 2D Architect (locked grid) ===== */
let pan={x:0,y:0}, zoom=1;
const ORIGIN={x:0,y:0}; // we keep grid anchored here
function recenter(){ pan.x=0; pan.y=0; }
function resetZoom(){ zoom=1; }

ui.recenter2d.addEventListener('click', ()=>{ recenter(); });
ui.zoomReset2d.addEventListener('click', ()=>{ resetZoom(); });

const Rbase=26;
function gridParams(){ const R=Rbase*zoom, stepX=R, stepY=R*Math.sqrt(3)/2; return {R,stepX,stepY}; }

const sketch=[]; // {type:'seg'|'arc'|'circ'|'pt', ...}
let polyLive=null, arcStart=null;

function centersNear(x,y,range=3){
  const {stepX,stepY}=gridParams();
  const rr=Math.round(y/stepY), cc=Math.round((x-(rr%2? stepX/2:0))/stepX);
  const pts=[];
  for(let dr=-range;dr<=range;dr++)
    for(let dc=-range;dc<=range;dc++){
      const r=rr+dr,c=cc+dc,gx=c*stepX+(r%2? stepX/2:0), gy=r*stepY;
      pts.push({x:gx,y:gy,kind:'center'});
    }
  // midpoints (dense but useful)
  const mids=[];
  for(let i=0;i<pts.length;i++){
    const a=pts[i];
    for(let j=i+1;j<pts.length;j++){
      const b=pts[j]; if(Math.hypot(a.x-b.x,a.y-b.y) < stepX*1.05){ mids.push({x:(a.x+b.x)/2,y:(a.y+b.y)/2,kind:'mid'}); }
    }
  }
  return pts.concat(mids);
}
function snap2D(clientX,clientY,strong){
  const {stepX,stepY}=gridParams();
  if(ui.snap2d.value==='free') return {x:clientX,y:clientY};
  const x = clientX - (pan.x % stepX);
  const y = clientY - (pan.y % stepY);
  const cand = centersNear(x,y,strong?4:3);
  let best=null,bd=1e9;
  cand.forEach(p=>{
    const sx=p.x + (pan.x % stepX), sy=p.y + (pan.y % stepY);
    const d2=(sx-clientX)*(sx-clientX)+(sy-clientY)*(sy-clientY);
    if(d2<bd){bd=d2; best={x:sx,y:sy};}
  });
  return best || {x:clientX,y:clientY};
}
function applyAngleLock(a0,a1,mode){
  if(mode==='off') return a1;
  const dx=a1.x-a0.x, dy=a1.y-a0.y, ang=Math.atan2(dy,dx);
  let snaps=[];
  if(mode==='ortho') snaps=[0,Math.PI/2,Math.PI,3*Math.PI/2];
  else if(mode==='thirty') snaps=[0,Math.PI/6,Math.PI/3,Math.PI/2,2*Math.PI/3,5*Math.PI/6,Math.PI,7*Math.PI/6,4*Math.PI/3,3*Math.PI/2,5*Math.PI/3,11*Math.PI/6];
  else if(mode==='fortyfive') snaps=[0,Math.PI/4,Math.PI/2,3*Math.PI/4,Math.PI,5*Math.PI/4,3*Math.PI/2,7*Math.PI/4];
  let best=ang,bd=1e9; snaps.forEach(s=>{const d=Math.abs(((ang-s+Math.PI)%(2*Math.PI))-Math.PI); if(d<bd){bd=d;best=s;}});
  const len=Math.hypot(dx,dy);
  return {x:a0.x+Math.cos(best)*len,y:a0.y+Math.sin(best)*len};
}

function drawGrid(){
  const {R,stepX,stepY}=gridParams();
  const w=canvas.width/DPR,h=canvas.height/DPR;
  // anchor grid at ORIGIN and keep stable
  ctx.save();
  ctx.translate((w/2 + ORIGIN.x) % stepX, (h/2 + ORIGIN.y) % stepY);
  ctx.lineWidth=0.9; ctx.strokeStyle='#00000018';
  const cols=Math.ceil(w/stepX)+4, rows=Math.ceil(h/stepY)+4;
  for(let r=-2;r<rows;r++){
    for(let c=-2;c<cols;c++){
      const x=c*stepX+(r%2? stepX/2:0), y=r*stepY;
      ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.stroke();
    }
  }
  ctx.restore();
}

/* Background image (photo align) */
const bg={img:null, alpha:0.5, scale:1, rot:0, offX:0, offY:0, calib:[]};
ui.bgUpload.addEventListener('change', (e)=>{
  const file=e.target.files[0]; if(!file) return;
  const fr=new FileReader(); fr.onload=()=>{ const im=new Image(); im.onload=()=>{ bg.img=im; render(0,true); }; im.src=fr.result; }; fr.readAsDataURL(file);
});
ui.bgAlpha.addEventListener('input', ()=>{ bg.alpha=+ui.bgAlpha.value; });
ui.bgScale.addEventListener('input', ()=>{ bg.scale=+ui.bgScale.value; });
ui.bgRot.addEventListener('input',  ()=>{ bg.rot=+ui.bgRot.value*Math.PI/180; });
ui.bgOffX.addEventListener('input', ()=>{ bg.offX=+ui.bgOffX.value; });
ui.bgOffY.addEventListener('input', ()=>{ bg.offY=+ui.bgOffY.value; });

ui.calibStart.addEventListener('click', ()=>{
  bg.calib=[]; alert('Calibration: click two points on the photo that should be N grid steps apart (set N).');
  calibMode=true;
});
let calibMode=false;
canvas.addEventListener('click', e=>{
  if(ui.mode.value!=='architect2d' || !calibMode || !bg.img) return;
  const p={x:e.clientX, y:e.clientY}; bg.calib.push(p);
  if(bg.calib.length===2){
    const N= Math.max(1, +ui.calibSteps.value||4);
    const dx=bg.calib[1].x - bg.calib[0].x, dy=bg.calib[1].y - bg.calib[0].y;
    const dist=Math.hypot(dx,dy);
    const {stepX}=gridParams();
    const target = N*stepX; // we want those picks to match N steps
    const s = target / dist;
    bg.scale *= s;
    bg.rot = Math.atan2(dy,dx); // align to grid x axis
    // move first pick onto nearest grid center
    const snapped = snap2D(bg.calib[0].x, bg.calib[0].y, true);
    bg.offX += snapped.x - bg.calib[0].x;
    bg.offY += snapped.y - bg.calib[0].y;
    // apply to controls
    ui.bgScale.value = bg.scale.toFixed(2);
    ui.bgRot.value   = Math.round(bg.rot*180/Math.PI);
    ui.bgOffX.value  = Math.round(bg.offX);
    ui.bgOffY.value  = Math.round(bg.offY);
    calibMode=false; bg.calib=[];
    alert('Calibrated. Adjust fine controls if needed.');
  }
});

/* Drawing */
ui.undo2d.addEventListener('click', ()=>{ sketch.pop(); render(0,true); });
ui.clear2d.addEventListener('click', ()=>{ sketch.length=0; render(0,true); });
ui.exportSvg.addEventListener('click', exportSVG);

function exportSVG(){
  const w=canvas.width/DPR,h=canvas.height/DPR;
  const p=[]; p.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" fill="none" stroke="#111" stroke-width="${+ui.stroke2d.value}">`);
  sketch.forEach(d=>{
    if(d.type==='seg') p.push(`<line x1="${d.a.x}" y1="${d.a.y}" x2="${d.b.x}" y2="${d.b.y}"/>`);
    if(d.type==='circ') p.push(`<circle cx="${d.c.x}" cy="${d.c.y}" r="${d.r}"/>`);
    if(d.type==='arc'){
      const x1=d.c.x+d.r*Math.cos(d.a1), y1=d.c.y+d.r*Math.sin(d.a1);
      const x2=d.c.x+d.r*Math.cos(d.a2), y2=d.c.y+d.r*Math.sin(d.a2);
      p.push(`<path d="M ${x1} ${y1} A ${d.r} ${d.r} 0 0 ${d.ccw?1:0} ${x2} ${y2}"/>`);
    }
  });
  p.push(`</svg>`);
  const blob = new Blob([p.join('\n')], {type:'image/svg+xml'});
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='universe120-architect.svg'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1500);
}

/* Input handling (2D) */
let dragging=false, lastX=0,lastY=0, spacePan=false;
function addSeg(A,B){ const wall=+ui.wallThick.value||0; sketch.push({type:'seg', a:A, b:B, wall}); }
canvas.addEventListener('mousedown', e=>{
  if(ui.mode.value!=='architect2d'){ dragging=true; lastX=e.clientX; lastY=e.clientY; return; }
  if(e.button!==0) return;
  const strong=e.shiftKey; let P = snap2D(e.clientX,e.clientY,strong);
  const tool=ui.tool2d.value;
  if(tool==='segment'){
    if(!polyLive) polyLive={points:[P]};
    else{
      let A=polyLive.points[polyLive.points.length-1], B=P;
      B = applyAngleLock(A,B,ui.lockAngle.value);
      addSeg(A,B); polyLive=null;
    }
  } else if(tool==='poly'){
    if(!polyLive) polyLive={points:[P]};
    else{
      let A=polyLive.points[polyLive.points.length-1], B=P;
      B = applyAngleLock(A,B,ui.lockAngle.value);
      polyLive.points.push(B); addSeg(A,B);
    }
  } else if(tool==='arc'){
    if(!arcStart) arcStart=P;
    else{
      const mx=(arcStart.x+P.x)/2, my=(arcStart.y+P.y)/2, r=Math.hypot(P.x-arcStart.x,P.y-arcStart.y)/2;
      const a1=Math.atan2(arcStart.y-my,arcStart.x-mx), a2=Math.atan2(P.y-my,P.x-mx);
      sketch.push({type:'arc', c:{x:mx,y:my}, r, a1, a2, ccw:false}); arcStart=null;
    }
  } else if(tool==='circle'){
    const {R}=gridParams(); sketch.push({type:'circ', c:{x:P.x,y:P.y}, r:R});
  } else if(tool==='erase'){
    let bi=-1, bd=1e9;
    sketch.forEach((d,i)=>{
      let cx=0,cy=0; if(d.type==='seg'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;}
      else if(d.type==='arc'){cx=d.c.x;cy=d.c.y;} else if(d.type==='circ'){cx=d.c.x;cy=d.c.y;}
      const dd=(cx-P.x)*(cx-P.x)+(cy-P.y)*(cy-P.y); if(dd<bd){bd=dd; bi=i;}
    });
    if(bi>=0) sketch.splice(bi,1);
  }
  render(0,true);
});
addEventListener('dblclick', e=>{ if(ui.mode.value==='architect2d' && ui.tool2d.value==='poly' && polyLive) polyLive=null; });
addEventListener('mousemove', e=>{
  if(ui.mode.value==='architect2d'){
    if(!ui.lockView.checked && (spacePan || dragging)){ pan.x += (e.movementX||0); pan.y += (e.movementY||0); }
  } else if(dragging){ rot.xy += (e.movementX||0)*0.005; rot.xz += (e.movementY||0)*0.005; }
});
addEventListener('mouseup', ()=>{ dragging=false; });
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const f=Math.exp(-e.deltaY*0.001);
  if(ui.mode.value==='architect2d'){
    // zoom about center (stable) to avoid "losing place"
    const before=zoom; zoom = Math.max(0.25, Math.min(5, zoom*f));
    if(ui.lockView.checked){ recenter(); } else {
      // keep center stable
      const w=canvas.width/DPR, h=canvas.height/DPR;
      const cx=w/2, cy=h/2;
      pan.x = cx - (cx - pan.x) * (zoom/before);
      pan.y = cy - (cy - pan.y) * (zoom/before);
    }
  } else {
    scale3d = Math.max(0.3, Math.min(2.5, scale3d * f));
  }
},{passive:false});
addEventListener('keydown', e=>{ if(e.code==='Space'){ spacePan=true; dragging=true; } });
addEventListener('keyup',   e=>{ if(e.code==='Space'){ spacePan=false; dragging=false; } });

/* ===== 3D Tutor (Pythagorean) ===== */
let scale3d=1.1, persp3d=3.0, rot={xy:0,xz:0,yz:0};
ui.reset3d.addEventListener('click', ()=>{ scale3d=1.1; persp3d=3.0; rot={xy:0,xz:0,yz:0}; });
ui.runProblem.addEventListener('click', ()=>{ stepIndex=0; runTutor(); });

function rot2(a,b,t){const c=Math.cos(t),s=Math.sin(t);return[a*c-b*s,a*s+b*c];}
function proj3(p, pz){ const z=p.z+pz; return {x:p.x/pz*pz/z, y:p.y/pz*pz/z, z:p.z}; }

let steps=[], stepIndex=0;
function runTutor(){
  const mode = ui.tutorMode.value;
  const a = Math.abs(+ui.legA.value||0), b = Math.abs(+ui.legB.value||0);
  const c = Math.sqrt(a*a + b*b);
  // build steps
  steps = [
    {t:'We have a right triangle with legs a and b. Place points at (0,0,0), (a,0,0), (0,b,0).'},
    {t:'Draw the legs: one of length a along X, one of length b along Y.'},
    {t:'Connect the endpoints to form the hypotenuse.'},
    {t:'By the Pythagorean Theorem, a² + b² = c². Compute c = √(a² + b²).'},
    {t:`With a=${a}, b=${b}, we get c ≈ ${c.toFixed(4)}.`}
  ];
  if(mode==='answer') stepIndex=steps.length-1;
  coach.innerHTML = renderCoach(steps, stepIndex, mode);
}

function renderCoach(steps, i, mode){
  return `
    <div><b>3D Tutor — ${mode==='learn'?'Learn':'Answer'}</b></div>
    <div style="margin:6px 0 10px;color:#333">${steps[i]?.t||'Press Run'}</div>
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button ${i<=0?'disabled':''} onclick="window.__prevStep()">Prev</button>
      <button ${i>=steps.length-1?'disabled':''} onclick="window.__nextStep()">Next</button>
      <button onclick="window.__showAnswer()">Show Answer</button>
    </div>
  `;
}
window.__prevStep = ()=>{ if(stepIndex>0){ stepIndex--; coach.innerHTML=renderCoach(steps,stepIndex,ui.tutorMode.value); } };
window.__nextStep = ()=>{ if(stepIndex<steps.length-1){ stepIndex++; coach.innerHTML=renderCoach(steps,stepIndex,ui.tutorMode.value); } };
window.__showAnswer = ()=>{ stepIndex=steps.length-1; coach.innerHTML=renderCoach(steps,stepIndex,ui.tutorMode.value); };

function drawTutor3D(){
  const a=Math.abs(+ui.legA.value||0), b=Math.abs(+ui.legB.value||0), c=Math.sqrt(a*a+b*b)||1;
  const s=140*scale3d, p=persp3d;
  // Points of right triangle in XY plane
  let A={x:0,y:0,z:0}, B={x:a,y:0,z:0}, C={x:0,y:b,z:0};
  const pts=[A,B,C].map(P=>{
    let x=P.x/c, y=P.y/c, z=P.z; // normalize so it fits view
    [x,y]=rot2(x,y,rot.xy+0.2); [y,z]=rot2(y,z,rot.xz+0.5);
    const q=proj3({x,y,z},p);
    return {x:canvas.width/DPR/2+q.x*s, y:canvas.height/DPR/2+q.y*s, z:q.z};
  });
  ctx.lineWidth=1.6; ctx.strokeStyle='#111'; ctx.fillStyle='#111';

  // Step-based reveal
  const showAB = stepIndex>=1, showAC = stepIndex>=1, showBC = stepIndex>=2;

  // points
  pts.forEach(pt=>{ ctx.beginPath(); ctx.arc(pt.x,pt.y,2.5,0,Math.PI*2); ctx.fill(); });

  // legs
  if(showAB){ ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y); ctx.lineTo(pts[1].x,pts[1].y); ctx.stroke(); }
  if(showAC){ ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y); ctx.lineTo(pts[2].x,pts[2].y); ctx.stroke(); }
  if(showBC){ ctx.beginPath(); ctx.moveTo(pts[1].x,pts[1].y); ctx.lineTo(pts[2].x,pts[2].y); ctx.stroke(); }

  // labels
  ctx.fillStyle='#222'; ctx.font='12px system-ui';
  ctx.fillText(`a=${a}`, (pts[0].x+pts[1].x)/2, (pts[0].y+pts[1].y)/2-6);
  ctx.fillText(`b=${b}`, (pts[0].x+pts[2].x)/2-18, (pts[0].y+pts[2].y)/2);
  if(showBC) ctx.fillText(`c≈${Math.sqrt(a*a+b*b).toFixed(3)}`, (pts[1].x+pts[2].x)/2, (pts[1].y+pts[2].y)/2-6);

  // footer tip
  ctx.fillStyle='#222'; ctx.font='12px system-ui';
  ctx.fillText('3D Tutor: Drag=rotate • Wheel=zoom • Use Learn mode to step through the proof', 16, canvas.height/DPR-18);
}

/* ===== Shared render ===== */
function drawBackground(){
  if(!bg.img) return;
  const w=canvas.width/DPR,h=canvas.height/DPR;
  ctx.save();
  ctx.globalAlpha=bg.alpha;
  // draw centered, then scale/rotate/offset
  ctx.translate(w/2 + bg.offX, h/2 + bg.offY);
  ctx.rotate(bg.rot);
  ctx.scale(bg.scale, bg.scale);
  ctx.drawImage(bg.img, -bg.img.width/2, -bg.img.height/2);
  ctx.restore();
}

let last=0;
function render(t, force=false){
  if(!force && t-last<14){ requestAnimationFrame(render); return; }
  last=t;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round';

  if(ui.mode.value==='architect2d'){
    drawBackground();
    drawGrid();
    // draw sketch
    ctx.lineWidth=+ui.stroke2d.value; ctx.strokeStyle='#111'; ctx.fillStyle='#111';
    sketch.forEach(d=>{
      if(d.type==='seg'){
        ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke();
        if(d.wall>0){
          const nx = d.b.y-d.a.y, ny = -(d.b.x-d.a.x); const L=Math.hypot(nx,ny)||1; const ux=nx/L, uy=ny/L, t=d.wall/2;
          ctx.beginPath(); ctx.moveTo(d.a.x+ux*t,d.a.y+uy*t); ctx.lineTo(d.b.x+ux*t,d.b.y+uy*t); ctx.lineTo(d.b.x-ux*t,d.b.y-uy*t); ctx.lineTo(d.a.x-ux*t,d.a.y-uy*t); ctx.closePath(); ctx.stroke();
        }
      }
      if(d.type==='arc'){ ctx.beginPath(); ctx.arc(d.c.x,d.c.y,d.r,d.a1,d.a2,d.ccw||false); ctx.stroke(); }
      if(d.type==='circ'){ ctx.beginPath(); ctx.arc(d.c.x,d.c.y,d.r,0,Math.PI*2); ctx.stroke(); }
    });
    // HUD
    ctx.fillStyle='#222'; ctx.font='12px system-ui';
    ctx.fillText('2D Architect (locked view): Shift=strong snap • Double-click ends polyline • SVG export for CAD/Illustrator', 16, canvas.height/DPR-18);
  } else {
    drawTutor3D();
  }

  ctx.restore();
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

// initialize coach text
coach.innerHTML = `<b>Welcome</b><br>Pick <i>2D Architect</i> to trace a photo and draft plans, or <i>3D Tutor</i> → Pythagorean to try Learn vs Answer.`;
} // end startApp
</script>
</body>
</html>
