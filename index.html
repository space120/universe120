<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Universe120 — Architect & Simulation Tutor</title>
<style>
:root{--bg:#f7f7fb;--card:#ffffffcc;--ink:#111;--muted:#666;--border:#e7e7ee;--brand:#3538ff}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
.site-header,.site-footer{position:fixed;left:0;right:0;display:flex;align-items:center;gap:16px;background:#fff8;backdrop-filter:saturate(1.8) blur(8px);border-bottom:1px solid var(--border);z-index:20}
.site-header{top:0;padding:10px 16px}
.site-footer{bottom:0;justify-content:center;border-top:1px solid var(--border);border-bottom:none;padding:8px 16px}
.brand{font-weight:800}
#ui.panel{position:fixed;left:16px;top:64px;z-index:15;background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px 14px;max-width:460px;box-shadow:0 6px 22px rgba(0,0,0,.07)}
#ui h1{margin:.25rem 0 .5rem;font-size:18px}
.row{display:flex;gap:8px;align-items:center;margin:.35rem 0}
label{font-size:12px;color:#444;min-width:120px}
input[type=range]{flex:1}
select,input[type=checkbox],input[type=number],input[type=text]{font-size:13px}
fieldset{border:1px dashed var(--border);border-radius:10px;padding:8px 10px;margin:.5rem 0 0}
fieldset legend{font-size:12px;color:#333;padding:0 6px}
button{appearance:none;border:1px solid var(--border);background:#fff;border-radius:10px;padding:8px 12px;font-size:13px;cursor:pointer}
button:hover{background:#f6f6ff}
button.primary{background:#3538ff;color:#fff;border-color:#3538ff}
.kbd{background:#eee;border:1px solid #ccc;border-bottom-color:#bbb;border-radius:4px;padding:0 4px;font-family:ui-monospace,Menlo,Consolas,monospace}
#canvas{display:block;width:100vw;height:100vh}
.overlay{position:fixed;right:16px;top:64px;z-index:16;background:var(--card);border:1px solid var(--border);border-radius:12px;padding:10px 12px;max-width:520px;box-shadow:0 6px 22px rgba(0,0,0,.07);font-size:13px}
@media (max-width: 700px){
  #ui.panel { max-width: 92vw; left: 4vw; }
  .row button, .row select, .row input[type=range], .row input[type=number], .row input[type=text] { min-height: 40px; }
}
/* Password gate */
#gate{position:fixed;inset:0;background:#0a0a0f;color:#eee;display:flex;align-items:center;justify-content:center;z-index:9999}
#gate .box{width:min(90vw,440px);background:#14141b;border:1px solid #2a2a35;border-radius:14px;padding:22px;box-shadow:0 10px 40px rgba(0,0,0,.35);text-align:center}
#gate input{width:100%;padding:12px;border-radius:10px;border:1px solid #39394a;background:#0e0e15;color:#eaeaf2}
#gate button{width:100%;margin-top:10px;background:#3538ff;color:#fff;border:0;padding:12px;border-radius:10px;font-size:15px}
.badge{font-size:11px;padding:2px 6px;border:1px solid var(--border);border-radius:999px;background:#fff}
</style>
</head>
<body>
<!-- ====== PASSWORD GATE ====== -->
<div id="gate" aria-modal="true">
  <div class="box">
    <h2>Universe120 — Private Build</h2>
    <p>Enter access key to view.</p>
    <input id="gateKey" type="password" placeholder="••••••">
    <button id="gateBtn">Enter</button>
    <small>Tip: set <b>ACCESS_KEY</b> in the code to change/disable.</small>
  </div>
</div>

<header class="site-header">
  <div class="brand">Universe120 <span class="badge">Architect & Simulation Tutor</span></div>
</header>

<aside id="ui" class="panel" hidden>
  <h1>Toolkit</h1>

  <div class="row">
    <label for="mode">Mode</label>
    <select id="mode">
      <option value="architect2d" selected>2D Architect</option>
      <option value="simTutor">Simulation Tutor (Math & Physics)</option>
    </select>
  </div>

  <!-- 2D Architect -->
  <fieldset id="arch2dBlock">
    <legend>2D Architect</legend>
    <div class="row"><label>Tool</label>
      <select id="tool2d">
        <option value="segment" selected>Segment</option>
        <option value="poly">Polyline</option>
        <option value="arc">Arc (two clicks)</option>
        <option value="circle">Circle (grid radius)</option>
        <option value="door">Door block</option>
        <option value="window">Window block</option>
        <option value="dim">Dimension</option>
        <option value="label">Room label</option>
        <option value="erase">Erase</option>
      </select>
    </div>
    <div class="row"><label>Snap</label>
      <select id="snap2d">
        <option value="intersections" selected>Intersections</option>
        <option value="centers">Circle Centers</option>
        <option value="midpoints">Midpoints</option>
        <option value="free">Free</option>
      </select>
    </div>
    <div class="row"><label>Angle Lock</label>
      <select id="lockAngle">
        <option value="off" selected>Off</option>
        <option value="ortho">0/90°</option>
        <option value="thirty">30/60/90°</option>
        <option value="fortyfive">45/90°</option>
      </select>
    </div>
    <div class="row"><label>Wall (px)</label><input id="wallThick" type="number" min="0" max="60" step="1" value="10"></div>
    <div class="row"><label>Parallel Offset</label><input id="wallOffset" type="number" min="0" max="80" step="1" value="36"> <button id="offsetBtn">Offset</button></div>
    <div class="row"><label>Stroke</label><input id="stroke2d" type="range" min="0.6" max="3" step="0.1" value="1.4"></div>

    <div class="row"><label>View</label>
      <span><input type="checkbox" id="lockView" checked> Lock View</span>
      <button id="recenter2d" type="button">Recenter</button>
      <button id="zoomReset2d" type="button">Reset Zoom</button>
    </div>

    <div class="row"><button id="undo2d">Undo</button><button id="clear2d">Clear</button><button id="exportSvg" class="primary">Export SVG</button></div>

    <div class="row"><label>Background</label>
      <input id="bgUpload" type="file" accept="image/*">
    </div>
    <div class="row"><label>BG Opacity</label><input id="bgAlpha" type="range" min="0" max="1" step="0.01" value="0.5"></div>
    <div class="row"><label>BG Scale</label><input id="bgScale" type="range" min="0.1" max="4" step="0.01" value="1"></div>
    <div class="row"><label>BG Rotate</label><input id="bgRot" type="range" min="-180" max="180" step="1" value="0"></div>
    <div class="row"><label>BG Offset</label><input id="bgOffX" type="number" value="0" style="width:80px"> <input id="bgOffY" type="number" value="0" style="width:80px"></div>

    <div class="row"><label>Calibrate</label>
      <button id="calibStart">Pick 2 pts</button>
      <input id="calibSteps" type="number" min="1" max="50" step="1" value="4" title="Grid steps between picks" style="width:80px">
    </div>

    <p style="font-size:11px;color:#666">Tips: <span class="kbd">Shift</span> strong snap • Double-click ends polyline • View is locked so you don’t lose your place</p>
  </fieldset>

  <!-- Simulation Tutor -->
  <fieldset id="simBlock" style="display:none">
    <legend>Simulation Tutor</legend>

    <div class="row"><label>Mode</label>
      <select id="tutorMode">
        <option value="learn" selected>Learn (guided)</option>
        <option value="answer">Answer (quick)</option>
      </select>
    </div>

    <div class="row"><label>Topic</label>
      <select id="topic">
        <option value="pythag" selected>Geometry — Pythagorean</option>
        <option value="vectors">Geometry — Vectors (|v| & dot)</option>
        <option value="solids">Geometry — Surface area & volume</option>
        <option value="projectile">Kinematics — Projectile motion</option>
        <option value="workEnergy">Dynamics — Work & Energy (ramp)</option>
        <option value="spring">Dynamics — Spring–Mass (SHM)</option>
      </select>
    </div>

    <!-- dynamic inputs panel gets injected here -->
    <div id="inputsArea" class="row" style="flex-wrap:wrap"></div>

    <div class="row"><label>3D View</label>
      <span><button id="reset3d">Reset</button></span>
    </div>
    <p style="font-size:11px;color:#666">Drag to rotate • Wheel to zoom • In Learn mode we reveal steps and ask questions before numbers.</p>
  </fieldset>
</aside>

<div id="coach" class="overlay" hidden></div>

<canvas id="canvas" hidden></canvas>

<footer class="site-footer">
  <small>© <span id="year"></span> Universe120 • Learn by building</small>
</footer>

<script>
/* ===== CONFIG ===== */
const ACCESS_KEY = '120beta'; // set '' to disable the gate
/* ================== */
document.getElementById('year').textContent = new Date().getFullYear();

/* Gate */
const gate = document.getElementById('gate');
const gateBtn = document.getElementById('gateBtn');
const gateKey = document.getElementById('gateKey');
function openSite(){ gate.remove(); document.getElementById('ui').hidden=false; document.getElementById('canvas').hidden=false; document.getElementById('coach').hidden=false; startApp(); }
function tryGate(){ if(ACCESS_KEY==='' || gateKey.value===ACCESS_KEY) openSite(); else alert('Incorrect key'); }
gateBtn.addEventListener('click', tryGate);
gateKey.addEventListener('keydown', e=>{ if(e.key==='Enter') tryGate(); });
if(ACCESS_KEY==='') openSite();

/* ===== APP ===== */
function startApp(){
const canvas = document.getElementById('canvas');
const coach = document.getElementById('coach');
const ctx = canvas.getContext('2d',{alpha:true});
let DPR = Math.min(devicePixelRatio||1,2);
function resize(){ const w=innerWidth,h=innerHeight; canvas.style.width=w+'px'; canvas.style.height=h+'px'; canvas.width=Math.round(w*DPR); canvas.height=Math.round(h*DPR); ctx.setTransform(DPR,0,0,DPR,0,0); }
addEventListener('resize',resize); resize();

const $=id=>document.getElementById(id);
const ui={
  mode:$('mode'),
  // 2D
  arch2dBlock:$('arch2dBlock'), tool2d:$('tool2d'), snap2d:$('snap2d'), lockAngle:$('lockAngle'),
  wallThick:$('wallThick'), wallOffset:$('wallOffset'), offsetBtn:$('offsetBtn'),
  stroke2d:$('stroke2d'), lockView:$('lockView'), recenter2d:$('recenter2d'), zoomReset2d:$('zoomReset2d'),
  undo2d:$('undo2d'), clear2d:$('clear2d'), exportSvg:$('exportSvg'),
  bgUpload:$('bgUpload'), bgAlpha:$('bgAlpha'), bgScale:$('bgScale'), bgRot:$('bgRot'), bgOffX:$('bgOffX'), bgOffY:$('bgOffY'),
  calibStart:$('calibStart'), calibSteps:$('calibSteps'),
  // Tutor
  simBlock:$('simBlock'), tutorMode:$('tutorMode'), topic:$('topic'), inputsArea:$('inputsArea'),
  reset3d:$('reset3d'),
};

ui.mode.addEventListener('change', ()=>{
  ui.arch2dBlock.style.display = ui.mode.value==='architect2d' ? '' : 'none';
  ui.simBlock.style.display   = ui.mode.value==='simTutor' ? '' : 'none';
  if(ui.mode.value==='simTutor'){ buildInputs(); stepIndex=0; }
});

/* ===== 2D Architect (locked grid + blocks + dims) ===== */
let pan={x:0,y:0}, zoom=1;
const ORIGIN={x:0,y:0};
function recenter(){ pan.x=0; pan.y=0; }
function resetZoom(){ zoom=1; }
ui.recenter2d.addEventListener('click', recenter);
ui.zoomReset2d.addEventListener('click', resetZoom);

const Rbase=26;
function gridParams(){ const R=Rbase*zoom, stepX=R, stepY=R*Math.sqrt(3)/2; return {R,stepX,stepY}; }

const sketch=[]; // {type:'seg'|'arc'|'circ'|'door'|'window'|'dim'|'label'}
let polyLive=null, arcStart=null;
let hoverPoint=null;

function centersNear(x,y,range=3){
  const {stepX,stepY}=gridParams();
  const rr=Math.round(y/stepY), cc=Math.round((x-(rr%2? stepX/2:0))/stepX);
  const pts=[];
  for(let dr=-range;dr<=range;dr++)
    for(let dc=-range;dc<=range;dc++){
      const r=rr+dr,c=cc+dc,gx=c*stepX+(r%2? stepX/2:0), gy=r*stepY;
      pts.push({x:gx,y:gy,kind:'center'});
    }
  const mids=[];
  for(let i=0;i<pts.length;i++){
    const a=pts[i];
    for(let j=i+1;j<pts.length;j++){
      const b=pts[j]; if(Math.hypot(a.x-b.x,a.y-b.y) < stepX*1.02){ mids.push({x:(a.x+b.x)/2,y:(a.y+b.y)/2,kind:'mid'}); }
    }
  }
  return pts.concat(mids);
}
function snap2D(clientX,clientY,strong){
  const {stepX,stepY}=gridParams();
  if(ui.snap2d.value==='free') return {x:clientX,y:clientY};
  const x = clientX - (pan.x % stepX);
  const y = clientY - (pan.y % stepY);
  const cand = centersNear(x,y,strong?4:3);
  let best=null,bd=1e9;
  cand.forEach(p=>{
    const sx=p.x + (pan.x % stepX), sy=p.y + (pan.y % stepY);
    const d2=(sx-clientX)*(sx-clientX)+(sy-clientY)*(sy-clientY);
    if(d2<bd){bd=d2; best={x:sx,y:sy,kind:p.kind};}
  });
  return best || {x:clientX,y:clientY,kind:'free'};
}
function applyAngleLock(a0,a1,mode){
  if(mode==='off') return a1;
  const dx=a1.x-a0.x, dy=a1.y-a0.y, ang=Math.atan2(dy,dx);
  let snaps=[];
  if(mode==='ortho') snaps=[0,Math.PI/2,Math.PI,3*Math.PI/2];
  else if(mode==='thirty') snaps=[0,Math.PI/6,Math.PI/3,Math.PI/2,2*Math.PI/3,5*Math.PI/6,Math.PI,7*Math.PI/6,4*Math.PI/3,3*Math.PI/2,5*Math.PI/3,11*Math.PI/6];
  else if(mode==='fortyfive') snaps=[0,Math.PI/4,Math.PI/2,3*Math.PI/4,Math.PI,5*Math.PI/4,3*Math.PI/2,7*Math.PI/4];
  let best=ang,bd=1e9; snaps.forEach(s=>{const d=Math.abs(((ang-s+Math.PI)%(2*Math.PI))-Math.PI); if(d<bd){bd=d;best=s;}});
  const len=Math.hypot(dx,dy);
  return {x:a0.x+Math.cos(best)*len,y:a0.y+Math.sin(best)*len};
}

function drawGrid(){
  const {R,stepX,stepY}=gridParams();
  const w=canvas.width/DPR,h=canvas.height/DPR;
  ctx.save();
  ctx.translate((w/2 + ORIGIN.x) % stepX, (h/2 + ORIGIN.y) % stepY);
  ctx.lineWidth=0.9; ctx.strokeStyle='#00000018';
  const cols=Math.ceil(w/stepX)+4, rows=Math.ceil(h/stepY)+4;
  for(let r=-2;r<rows;r++){
    for(let c=-2;c<cols;c++){
      const x=c*stepX+(r%2? stepX/2:0), y=r*stepY;
      ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.stroke();
    }
  }
  ctx.restore();
}

/* Background image (photo align) */
const bg={img:null, alpha:0.5, scale:1, rot:0, offX:0, offY:0, calib:[]};
ui.bgUpload.addEventListener('change', (e)=>{
  const file=e.target.files[0]; if(!file) return;
  const fr=new FileReader(); fr.onload=()=>{ const im=new Image(); im.onload=()=>{ bg.img=im; }; im.src=fr.result; }; fr.readAsDataURL(file);
});
ui.bgAlpha.addEventListener('input', ()=>{ bg.alpha=+ui.bgAlpha.value; });
ui.bgScale.addEventListener('input', ()=>{ bg.scale=+ui.bgScale.value; });
ui.bgRot.addEventListener('input',  ()=>{ bg.rot=+ui.bgRot.value*Math.PI/180; });
ui.bgOffX.addEventListener('input', ()=>{ bg.offX=+ui.bgOffX.value; });
ui.bgOffY.addEventListener('input', ()=>{ bg.offY=+ui.bgOffY.value; });
ui.calibStart.addEventListener('click', ()=>{
  bg.calib=[]; alert('Calibration: click two points on the photo that should be N grid steps apart (set N).');
  calibMode=true;
});
let calibMode=false;
canvas.addEventListener('click', e=>{
  if(ui.mode.value!=='architect2d' || !calibMode || !bg.img) return;
  const p={x:e.clientX, y:e.clientY}; bg.calib.push(p);
  if(bg.calib.length===2){
    const N= Math.max(1, +ui.calibSteps.value||4);
    const dx=bg.calib[1].x - bg.calib[0].x, dy=bg.calib[1].y - bg.calib[0].y;
    const dist=Math.hypot(dx,dy);
    const {stepX}=gridParams();
    const target = N*stepX;
    const s = target / dist;
    bg.scale *= s;
    bg.rot = Math.atan2(dy,dx);
    const snapped = snap2D(bg.calib[0].x, bg.calib[0].y, true);
    bg.offX += snapped.x - bg.calib[0].x;
    bg.offY += snapped.y - bg.calib[0].y;
    ui.bgScale.value = bg.scale.toFixed(2);
    ui.bgRot.value   = Math.round(bg.rot*180/Math.PI);
    ui.bgOffX.value  = Math.round(bg.offX);
    ui.bgOffY.value  = Math.round(bg.offY);
    calibMode=false; bg.calib=[];
    alert('Calibrated. Adjust fine controls if needed.');
  }
});

/* Drawing + blocks + dims */
function addSeg(A,B,wall){ sketch.push({type:'seg', a:A, b:B, wall:wall||0}); }
function addDoor(center,dirLen=40, swing=1){ sketch.push({type:'door',c:center,len:dirLen,swing}); }
function addWindow(A,B){ sketch.push({type:'window',a:A,b:B}); }
function addDim(A,B,label){ sketch.push({type:'dim',a:A,b:B,text:label||''}); }
function addLabel(P,text){ sketch.push({type:'label',p:P,text:text||'Room'}); }

ui.undo2d.addEventListener('click', ()=>{ sketch.pop(); });
ui.clear2d.addEventListener('click', ()=>{ sketch.length=0; });
ui.offsetBtn.addEventListener('click', ()=>{
  const off=+ui.wallOffset.value||0; // simple parallel offset for last segment
  const last=[...sketch].reverse().find(d=>d.type==='seg');
  if(!last){ alert('Draw a wall segment first.'); return; }
  const nx = last.b.y-last.a.y, ny=-(last.b.x-last.a.x); const L=Math.hypot(nx,ny)||1; const ux=nx/L, uy=ny/L;
  const A={x:last.a.x+ux*off, y:last.a.y+uy*off}, B={x:last.b.x+ux*off, y:last.b.y+uy*off};
  addSeg(A,B,last.wall);
});
ui.exportSvg.addEventListener('click', ()=>{
  const w=canvas.width/DPR,h=canvas.height/DPR, sw=+ui.stroke2d.value;
  const out=[];
  out.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" fill="none">`);
  out.push(`<g id="walls" stroke="#111" stroke-width="${sw}">`);
  sketch.forEach(d=>{ if(d.type==='seg'){ out.push(`<line x1="${d.a.x}" y1="${d.a.y}" x2="${d.b.x}" y2="${d.b.y}"/>`); }});
  out.push(`</g><g id="arcs" stroke="#111" stroke-width="${sw}">`);
  sketch.forEach(d=>{ if(d.type==='arc'){ const x1=d.c.x+d.r*Math.cos(d.a1), y1=d.c.y+d.r*Math.sin(d.a1); const x2=d.c.x+d.r*Math.cos(d.a2), y2=d.c.y+d.r*Math.sin(d.a2); out.push(`<path d="M ${x1} ${y1} A ${d.r} ${d.r} 0 0 ${d.ccw?1:0} ${x2} ${y2}"/>`); }});
  out.push(`</g><g id="doors" stroke="#0077ff" stroke-width="${sw}">`);
  sketch.forEach(d=>{ if(d.type==='door'){ out.push(`<circle cx="${d.c.x}" cy="${d.c.y}" r="2"/>`); }});
  out.push(`</g><g id="windows" stroke="#00aa66" stroke-width="${sw}">`);
  sketch.forEach(d=>{ if(d.type==='window'){ out.push(`<line x1="${d.a.x}" y1="${d.a.y}" x2="${d.b.x}" y2="${d.b.y}"/>`); }});
  out.push(`</g><g id="dims" stroke="#cc0000" stroke-width="${Math.max(1,sw-0.4)}" fill="#cc0000">`);
  sketch.forEach(d=>{ if(d.type==='dim'){ const mx=(d.a.x+d.b.x)/2, my=(d.a.y+d.b.y)/2; out.push(`<line x1="${d.a.x}" y1="${d.a.y}" x2="${d.b.x}" y2="${d.b.y}"/>`); out.push(`<text x="${mx+4}" y="${my-4}" font-size="12">${d.text||''}</text>`); }});
  out.push(`</g><g id="labels" fill="#333">`);
  sketch.forEach(d=>{ if(d.type==='label'){ out.push(`<text x="${d.p.x}" y="${d.p.y}" font-size="14">${(d.text||'Room')}</text>`); }});
  out.push(`</g></svg>`);
  const blob = new Blob([out.join('\n')],{type:'image/svg+xml'}); const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='universe120-plan.svg'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1500);
});

/* Input handling (2D) */
let dragging=false, lastX=0,lastY=0, spacePan=false;
canvas.addEventListener('mousedown', e=>{
  if(ui.mode.value!=='architect2d'){ dragging=true; lastX=e.clientX; lastY=e.clientY; return; }
  if(e.button!==0) return;
  const strong=e.shiftKey; let P = snap2D(e.clientX,e.clientY,strong);
  const tool=ui.tool2d.value;
  if(tool==='segment'){
    if(!polyLive) polyLive={points:[P]};
    else{
      let A=polyLive.points[polyLive.points.length-1], B=P;
      B = applyAngleLock(A,B,ui.lockAngle.value);
      addSeg(A,B,+ui.wallThick.value||0); polyLive=null;
    }
  } else if(tool==='poly'){
    if(!polyLive) polyLive={points:[P]};
    else{
      let A=polyLive.points[polyLive.points.length-1], B=P;
      B = applyAngleLock(A,B,ui.lockAngle.value);
      polyLive.points.push(B); addSeg(A,B,+ui.wallThick.value||0);
    }
  } else if(tool==='arc'){
    if(!arcStart) arcStart=P;
    else{
      const mx=(arcStart.x+P.x)/2, my=(arcStart.y+P.y)/2, r=Math.hypot(P.x-arcStart.x,P.y-arcStart.y)/2;
      const a1=Math.atan2(arcStart.y-my,arcStart.x-mx), a2=Math.atan2(P.y-my,P.x-mx);
      sketch.push({type:'arc', c:{x:mx,y:my}, r, a1, a2, ccw:false}); arcStart=null;
    }
  } else if(tool==='circle'){
    const {R}=gridParams(); sketch.push({type:'circ', c:{x:P.x,y:P.y}, r:R});
  } else if(tool==='door'){
    addDoor(P, 40, 1);
  } else if(tool==='window'){
    if(!polyLive) polyLive={points:[P]}; else { addWindow(polyLive.points[0], P); polyLive=null; }
  } else if(tool==='dim'){
    if(!polyLive) polyLive={points:[P]}; else {
      const A=polyLive.points[0], B=P; const len = Math.hypot(B.x-A.x, B.y-A.y).toFixed(1);
      addDim(A,B, `${len}px`); polyLive=null;
    }
  } else if(tool==='label'){
    const text=prompt('Room name (e.g., Kitchen):','Room')||'Room'; addLabel(P,text);
  } else if(tool==='erase'){
    let bi=-1, bd=1e9;
    sketch.forEach((d,i)=>{
      let cx=0,cy=0;
      if(d.type==='seg'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;}
      else if(d.type==='arc'){cx=d.c.x;cy=d.c.y;}
      else if(d.type==='circ'){cx=d.c.x;cy=d.c.y;}
      else if(d.type==='door'){cx=d.c.x;cy=d.c.y;}
      else if(d.type==='window'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;}
      else if(d.type==='dim'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;}
      else if(d.type==='label'){cx=d.p.x;cy=d.p.y;}
      const dd=(cx-P.x)*(cx-P.x)+(cy-P.y)*(cy-P.y); if(dd<bd){bd=dd; bi=i;}
    });
    if(bi>=0) sketch.splice(bi,1);
  }
});
addEventListener('dblclick', e=>{ if(ui.mode.value==='architect2d' && polyLive) polyLive=null; });
addEventListener('mousemove', e=>{
  hoverPoint = snap2D(e.clientX,e.clientY,false);
  if(ui.mode.value==='architect2d'){
    if(!ui.lockView.checked && (spacePan || dragging)){ pan.x += (e.movementX||0); pan.y += (e.movementY||0); }
  } else if(dragging){ rot.xy += (e.movementX||0)*0.005; rot.xz += (e.movementY||0)*0.005; }
});
addEventListener('mouseup', ()=>{ dragging=false; });
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const f=Math.exp(-e.deltaY*0.001);
  if(ui.mode.value==='architect2d'){
    const before=zoom; zoom = Math.max(0.25, Math.min(5, zoom*f));
    if(ui.lockView.checked){ recenter(); }
    else{
      const w=canvas.width/DPR, h=canvas.height/DPR; const cx=w/2, cy=h/2;
      pan.x = cx - (cx - pan.x) * (zoom/before);
      pan.y = cy - (cy - pan.y) * (zoom/before);
    }
  } else {
    scale3d = Math.max(0.3, Math.min(2.5, scale3d * f));
  }
},{passive:false});
addEventListener('keydown', e=>{ if(e.code==='Space'){ spacePan=true; dragging=true; } });
addEventListener('keyup',   e=>{ if(e.code==='Space'){ spacePan=false; dragging=false; } });

/* ===== Simulation Tutor (modular) ===== */
let scale3d=1.1, persp3d=3.0, rot={xy:0,xz:0,yz:0}; ui.reset3d.addEventListener('click', ()=>{ scale3d=1.1; persp3d=3.0; rot={xy:0,xz:0,yz:0}; });

const topics = {
  pythag: {
    name:'Pythagorean',
    inputs:[{id:'a',label:'a',type:'number',value:3,step:'0.01'},{id:'b',label:'b',type:'number',value:4,step:'0.01'}],
    steps:(p)=>[
      'Place a right triangle with legs a and b in the XY plane.',
      'Draw legs along the axes so they are perpendicular.',
      'Connect endpoints to form the hypotenuse.',
      'By the Pythagorean theorem a² + b² = c².',
      `Compute c = √(a² + b²) with a=${p.a}, b=${p.b}.`
    ],
    compute:(p)=>({c:Math.sqrt(p.a*p.a+p.b*p.b)}),
    draw:(p,ans)=>{ // right triangle
      const a=p.a, b=p.b, c=ans.c||1;
      const A={x:0,y:0,z:0}, B={x:a,y:0,z:0}, C={x:0,y:b,z:0}; drawTri([A,B,C], {labels:{AB:`a=${a}`, AC:`b=${b}`, BC:`c≈${ans.c.toFixed(3)}`}});
    }
  },
  vectors:{
    name:'Vectors (|v| & dot)',
    inputs:[{id:'vx',label:'v.x',type:'number',value:3,step:'0.01'},{id:'vy',label:'v.y',type:'number',value:4,step:'0.01'},{id:'wx',label:'w.x',type:'number',value:4,step:'0.01'},{id:'wy',label:'w.y',type:'number',value:0,step:'0.01'}],
    steps:(p)=>[
      'Draw vectors v and w from the origin.',
      'Compute magnitudes |v| and |w|.',
      'Compute dot product v·w = |v||w|cosθ.',
      'Solve for θ using cosθ = (v·w)/(|v||w|).',
      'Interpret θ as the angle between v and w.'
    ],
    compute:(p)=>{
      const vmag=Math.hypot(p.vx,p.vy), wmag=Math.hypot(p.wx,p.wy), dot=p.vx*p.wx+p.vy*p.wy;
      const cos = (vmag&&wmag)? (dot/(vmag*wmag)) : 0; const theta=Math.acos(Math.max(-1,Math.min(1,cos)));
      return {vmag,wmag,dot,theta};
    },
    draw:(p,ans)=>{
      const A={x:0,y:0,z:0}, V={x:p.vx,y:p.vy,z:0}, W={x:p.wx,y:p.wy,z:0};
      drawAxes(); drawVector(A,V,'v'); drawVector(A,W,'w');
      annotate(`${'|v|='}${ans.vmag.toFixed(3)}, |w|=${ans.wmag.toFixed(3)}, v·w=${ans.dot.toFixed(3)}, θ≈${(ans.theta*180/Math.PI).toFixed(1)}°`);
    }
  },
  solids:{
    name:'Surface area & volume',
    inputs:[{id:'kind',label:'Solid',type:'select',options:['cube','sphere','cylinder']},{id:'s',label:'Side / r',type:'number',value:1,step:'0.01'},{id:'h',label:'h (for cylinder)',type:'number',value:2,step:'0.01'}],
    steps:(p)=>[
      'Pick a solid and show its 3D representation.',
      'Recall formulas for surface area and volume.',
      'Plug in dimensions and compute.',
      'Interpret units (area^2, volume^3).'
    ],
    compute:(p)=>{
      if(p.kind==='cube'){ return {SA:6*p.s*p.s, V: p.s**3}; }
      if(p.kind==='sphere'){ return {SA:4*Math.PI*p.s*p.s, V:(4/3)*Math.PI*p.s**3}; }
      if(p.kind==='cylinder'){ return {SA:2*Math.PI*p.s*(p.s+p.h), V:Math.PI*p.s*p.s*p.h}; }
      return {};
    },
    draw:(p,ans)=>{
      drawSolid(p.kind,p.s,p.h);
      annotate(`SA≈${(ans.SA||0).toFixed(3)}, V≈${(ans.V||0).toFixed(3)}`);
    }
  },
  projectile:{
    name:'Projectile motion',
    inputs:[
      {id:'v0',label:'v₀ (m/s)',type:'number',value:20,step:'0.1'},
      {id:'ang',label:'θ (deg)',type:'number',value:45,step:'0.1'},
      {id:'g',label:'g (m/s²)',type:'number',value:9.81,step:'0.01'},
      {id:'h0',label:'y₀ (m)',type:'number',value:0,step:'0.1'}
    ],
    steps:(p)=>[
      'Resolve initial velocity into components: v₀x=v₀cosθ, v₀y=v₀sinθ.',
      'Use y(t)=y₀+v₀y t -(1/2) g t² to find time of flight.',
      'Range R = v₀x · T, Peak H = y₀ + v₀y²/(2g).',
      'Plot the trajectory in the x–y plane.',
      'Discuss how angle and speed affect R and H.'
    ],
    compute:(p)=>{
      const ang=p.ang*Math.PI/180, v0x=p.v0*Math.cos(ang), v0y=p.v0*Math.sin(ang);
      const g=p.g, y0=p.h0;
      // Solve y(t)=0 for landing (quadratic)
      const a=-0.5*g, b=v0y, c=y0;
      const D=b*b-4*a*c; const T = (D<0)?0: ( (-b + Math.sqrt(D)) / (2*a) );
      const R=v0x*T, H=y0 + v0y*v0y/(2*g);
      return {v0x,v0y,T,R,H};
    },
    draw:(p,ans)=>{
      drawAxes();
      // plot 2D trajectory scaled into 3D canvas plane
      const pts=[]; const N=80; for(let i=0;i<=N;i++){ const t=ans.T*i/N; const x=ans.v0x*t; const y=p.h0 + ans.v0y*t - 0.5*p.g*t*t; pts.push({x,y}); }
      drawCurveXY(pts);
      annotate(`T≈${ans.T.toFixed(2)} s, R≈${ans.R.toFixed(2)} m, H≈${ans.H.toFixed(2)} m`);
    }
  },
  workEnergy:{
    name:'Work–Energy (ramp)',
    inputs:[{id:'m',label:'Mass m (kg)',type:'number',value:1,step:'0.1'},{id:'h',label:'Height h (m)',type:'number',value:2,step:'0.1'},{id:'mu',label:'Friction μ',type:'number',value:0.1,step:'0.01'},{id:'g',label:'g (m/s²)',type:'number',value:9.81,step:'0.01'}],
    steps:(p)=>[
      'Potential energy at top: PE = mgh.',
      'Down the ramp, friction does negative work: W_f = −μ N s.',
      'Energy balance: KE_bottom = mgh + W_other − |W_f|.',
      'Compute speed at bottom from KE = 1/2 m v² (if positive).',
      'Visualize the ramp and forces.'
    ],
    compute:(p)=>{
      const s = Math.sqrt(p.h*p.h + 4*p.h); // simple slanted length guess (just illustrative)
      const N = p.m * p.g * (p.h/s); // crude normal ~ mg cos
      const Wf = -p.mu * N * s;
      const PE = p.m*p.g*p.h;
      const KE = Math.max(0, PE + Wf);
      const v = Math.sqrt((2*KE)/p.m);
      return {PE,Wf,KE,v};
    },
    draw:(p,ans)=>{
      drawRamp(p.h); annotate(`PE=${ans.PE.toFixed(1)} J, W_f≈${ans.Wf.toFixed(1)} J, v≈${ans.v.toFixed(2)} m/s`);
    }
  },
  spring:{
    name:'Spring–Mass (SHM)',
    inputs:[{id:'k',label:'k (N/m)',type:'number',value:10,step:'0.1'},{id:'m',label:'m (kg)',type:'number',value:1,step:'0.1'},{id:'A',label:'Amplitude A (m)',type:'number',value:1,step:'0.01'}],
    steps:(p)=>[
      'Natural frequency: ω = √(k/m).',
      'Position: x(t)=A cos(ω t). Velocity, acceleration follow.',
      'Total energy stays constant (no damping).',
      'Animate mass oscillation.',
      'Relate period T = 2π/ω.'
    ],
    compute:(p)=>{
      const w=Math.sqrt(p.k/p.m), T=2*Math.PI/w;
      return {w,T};
    },
    draw:(p,ans,elapsed)=>{
      drawSpring(p.A, ans.w, elapsed);
      annotate(`ω≈${ans.w.toFixed(2)} rad/s, T≈${ans.T.toFixed(2)} s`);
    }
  }
};

function buildInputs(){
  const t = topics[ui.topic.value];
  ui.inputsArea.innerHTML='';
  t.inputs.forEach(inp=>{
    const wrap=document.createElement('div'); wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.gap='6px'; wrap.style.margin='4px 0';
    const lab=document.createElement('label'); lab.textContent=inp.label; lab.style.minWidth='90px';
    let el; if(inp.type==='select'){ el=document.createElement('select'); inp.options.forEach(opt=>{const o=document.createElement('option'); o.value=opt;o.textContent=opt; el.appendChild(o);}); }
    else { el=document.createElement('input'); el.type='number'; el.step=inp.step||'1'; el.value=inp.value; }
    el.id=`inp_${inp.id}`; wrap.appendChild(lab); wrap.appendChild(el); ui.inputsArea.appendChild(wrap);
  });
  // Controls
  const run=document.createElement('button'); run.textContent='Run'; run.className='primary'; run.onclick=()=>{ stepIndex=0; runTutor(); };
  ui.inputsArea.appendChild(run);
}
ui.topic.addEventListener('change', ()=>{ buildInputs(); stepIndex=0; });
ui.tutorMode.addEventListener('change', ()=>{ stepIndex=0; });

function getParams(){
  const t=topics[ui.topic.value]; const p={};
  t.inputs.forEach(inp=>{
    const el=document.getElementById(`inp_${inp.id}`); if(!el) return;
    if(inp.type==='select') p[inp.id]=el.value;
    else p[inp.id]=+el.value;
  });
  return p;
}

let steps=[], stepIndex=0;
function runTutor(){
  const t=topics[ui.topic.value], p=getParams();
  steps = t.steps(p);
  const mode=ui.tutorMode.value;
  if(mode==='answer') stepIndex=steps.length-1;
  const ans = t.compute ? t.compute(p) : {};
  coach.innerHTML = renderCoach(steps, stepIndex, mode, t, p, ans);
}

function renderCoach(steps,i,mode,t,p,ans){
  const facts = (()=>{
    if(ui.topic.value==='pythag') return `c = √(a² + b²) = √(${p.a}² + ${p.b}²) = ${Math.sqrt(p.a*p.a+p.b*p.b).toFixed(4)}`;
    if(ui.topic.value==='vectors') return `|v|=${Math.hypot(p.vx,p.vy).toFixed(3)}, |w|=${Math.hypot(p.wx,p.wy).toFixed(3)}, v·w=${(p.vx*p.wx+p.vy*p.wy).toFixed(3)}`;
    if(ui.topic.value==='projectile'){
      const ang=p.ang*Math.PI/180, vx=(p.v0*Math.cos(ang)).toFixed(2), vy=(p.v0*Math.sin(ang)).toFixed(2);
      return `v₀x=${vx}, v₀y=${vy}, T≈${ans.T?.toFixed(2)} s, R≈${ans.R?.toFixed(2)} m, H≈${ans.H?.toFixed(2)} m`;
    }
    if(ui.topic.value==='solids') return `SA≈${(ans.SA||0).toFixed(3)}, V≈${(ans.V||0).toFixed(3)}`;
    if(ui.topic.value==='workEnergy') return `PE=${ans.PE?.toFixed(1)} J, W_f≈${ans.Wf?.toFixed(1)} J, v≈${ans.v?.toFixed(2)} m/s`;
    if(ui.topic.value==='spring') return `ω≈${ans.w?.toFixed(2)} rad/s, T≈${ans.T?.toFixed(2)} s`;
    return '';
  })();
  return `
    <div><b>Simulation Tutor — ${topics[ui.topic.value].name}</b> <span style="opacity:.7">(${mode==='learn'?'Learn':'Answer'})</span></div>
    <div style="margin:6px 0 10px;color:#333">${steps[i]||'Press Run'}</div>
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button ${i<=0?'disabled':''} onclick="window.__prevStep()">Prev</button>
      <button ${i>=steps.length-1?'disabled':''} onclick="window.__nextStep()">Next</button>
      <button onclick="window.__showAnswer()">Show Answer</button>
    </div>
    <div style="margin-top:8px;color:#222"><i>${facts}</i></div>
  `;
}
window.__prevStep = ()=>{ if(stepIndex>0){ stepIndex--; runTutor(); } };
window.__nextStep = ()=>{ if(stepIndex<steps.length-1){ stepIndex++; runTutor(); } };
window.__showAnswer = ()=>{ stepIndex=steps.length-1; runTutor(); };

/* ===== 3D drawing helpers (shared) ===== */
function rot2(a,b,t){const c=Math.cos(t),s=Math.sin(t);return[a*c-b*s,a*s+b*c];}
function proj3(p, pz){ const z=p.z+pz; return {x:p.x/pz*pz/z, y:p.y/pz*pz/z, z:p.z}; }

function drawAxes(){
  const s=140*scale3d, p=persp3d;
  const O={x:0,y:0,z:0}, X={x:1,y:0,z:0}, Y={x:0,y:1,z:0};
  [O,X,Y].forEach(Q=>{ let {x,y,z}=Q; [x,y]=rot2(x,y,rot.xy+0.2); [y,z]=rot2(y,z,rot.xz+0.5); const q=proj3({x,y,z},p); Q._sx=canvas.width/DPR/2+q.x*s; Q._sy=canvas.height/DPR/2+q.y*s; });
  ctx.strokeStyle='#888'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(O._sx,O._sy); ctx.lineTo(X._sx,X._sy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(O._sx,O._sy); ctx.lineTo(Y._sx,Y._sy); ctx.stroke();
}
function drawVector(A,B,label){
  const s=140*scale3d, p=persp3d;
  const T=[A,B].map(P=>{ let x=P.x,y=P.y,z=P.z; [x,y]=rot2(x,y,rot.xy+0.2); [y,z]=rot2(y,z,rot.xz+0.5); const q=proj3({x,y,z},p); return {x:canvas.width/DPR/2+q.x*s, y:canvas.height/DPR/2+q.y*s};});
  ctx.strokeStyle='#111'; ctx.lineWidth=1.6; ctx.beginPath(); ctx.moveTo(T[0].x,T[0].y); ctx.lineTo(T[1].x,T[1].y); ctx.stroke();
  ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(T[1].x,T[1].y,2.4,0,Math.PI*2); ctx.fill();
  if(label){ ctx.font='12px system-ui'; ctx.fillText(label,T[1].x+6,T[1].y-6); }
}
function drawTri(pts,{labels}={}){
  const s=140*scale3d, p=persp3d;
  const T=pts.map(P=>{ let x=P.x,y=P.y,z=P.z; [x,y]=rot2(x,y,rot.xy+0.2); [y,z]=rot2(y,z,rot.xz+0.5); const q=proj3({x,y,z},p); return {x:canvas.width/DPR/2+q.x*s, y:canvas.height/DPR/2+q.y*s};});
  ctx.strokeStyle='#111'; ctx.lineWidth=1.6;
  [[0,1],[0,2],[1,2]].forEach(([i,j])=>{ ctx.beginPath(); ctx.moveTo(T[i].x,T[i].y); ctx.lineTo(T[j].x,T[j].y); ctx.stroke(); });
  if(labels){
    ctx.fillStyle='#222'; ctx.font='12px system-ui';
    ctx.fillText(labels.AB||'', (T[0].x+T[1].x)/2, (T[0].y+T[1].y)/2 - 6);
    ctx.fillText(labels.AC||'', (T[0].x+T[2].x)/2 - 16, (T[0].y+T[2].y)/2);
    ctx.fillText(labels.BC||'', (T[1].x+T[2].x)/2, (T[1].y+T[2].y)/2 - 6);
  }
}
function drawCurveXY(raw){
  const s=140*scale3d, p=persp3d;
  ctx.strokeStyle='#111'; ctx.lineWidth=1.6; ctx.beginPath();
  raw.forEach((P,i)=>{ let x=P.x,y=P.y,z=0; [x,y]=rot2(x,y,rot.xy+0.2); [y,z]=rot2(y,z,rot.xz+0.5); const q=proj3({x,y,z},p); const sx=canvas.width/DPR/2+q.x*s, sy=canvas.height/DPR/2+q.y*s; if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy); });
  ctx.stroke();
}
function drawSolid(kind,s,h){
  // very simple previews
  if(kind==='cube'){
    const v=[[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]].map(a=>({x:a[0],y:a[1],z:a[2]}));
    drawWire(v,[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]]);
  } else if(kind==='sphere'){
    // rings
    ctx.strokeStyle='#111'; ctx.lineWidth=1.2;
    for(let k=0;k<=10;k++){ const th=-Math.PI/2 + Math.PI*k/10; const r=Math.cos(th), z=Math.sin(th); drawCircle3D(r, z); }
  } else if(kind==='cylinder'){
    // two circles + side lines
    drawCircle3D(1,-h/2); drawCircle3D(1,h/2);
    drawWire([{x:1,y:0,z:-h/2},{x:1,y:0,z:h/2}],[[0,1]]);
    drawWire([{x:-1,y:0,z:-h/2},{x:-1,y:0,z:h/2}],[[0,1]]);
  }
}
function drawWire(v,e){
  const s=120*scale3d, p=persp3d;
  const T=v.map(P=>{ let x=P.x,y=P.y,z=P.z; [x,y]=rot2(x,y,rot.xy+0.2); [y,z]=rot2(y,z,rot.xz+0.5); const q=proj3({x,y,z},p); return {x:canvas.width/DPR/2+q.x*s, y:canvas.height/DPR/2+q.y*s};});
  ctx.strokeStyle='#111'; ctx.lineWidth=1.2;
  e.forEach(([i,j])=>{ ctx.beginPath(); ctx.moveTo(T[i].x,T[i].y); ctx.lineTo(T[j].x,T[j].y); ctx.stroke(); });
}
function drawCircle3D(r,z){
  // project a circle r at height z by sampling
  const pts=[]; const n=64; for(let i=0;i<=n;i++){ const a=2*Math.PI*i/n; pts.push({x:r*Math.cos(a), y:r*Math.sin(a), z}); }
  const s=120*scale3d, p=persp3d;
  ctx.beginPath();
  pts.forEach((P,i)=>{ let x=P.x,y=P.y, z=P.z; [x,y]=rot2(x,y,rot.xy+0.2); [y,z]=rot2(y,z,rot.xz+0.5); const q=proj3({x,y,z},p); const sx=canvas.width/DPR/2+q.x*s, sy=canvas.height/DPR/2+q.y*s; if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy); });
  ctx.stroke();
}
function drawRamp(h){
  // simple right triangle ramp
  const A={x:-1,y:-0.5,z:0}, B={x:1,y:-0.5,z:0}, C={x:1,y:-0.5+h/2,z:0};
  drawTri([A,B,C],{});
}
function drawSpring(A,w,elapsed){
  const x=A*Math.cos(w*(elapsed/1000));
  const pts=[]; const turns=10, n=120;
  for(let i=0;i<=n;i++){ const t=i/n; const a=turns*2*Math.PI*t; const y= -0.8 + 1.6*t; const r=0.1; pts.push({x:r*Math.cos(a)+x*0.2, y:y, z:r*Math.sin(a)}); }
  drawCurve3D(pts);
  annotate(`x(t)=A cos(ωt), x≈${x.toFixed(2)} m`);
}
function drawCurve3D(pts){
  const s=140*scale3d, p=persp3d;
  ctx.strokeStyle='#111'; ctx.lineWidth=1.4; ctx.beginPath();
  pts.forEach((P,i)=>{ let x=P.x,y=P.y,z=P.z; [x,y]=rot2(x,y,rot.xy+0.2); [y,z]=rot2(y,z,rot.xz+0.5); const q=proj3({x,y,z},p); const sx=canvas.width/DPR/2+q.x*s, sy=canvas.height/DPR/2+q.y*s; if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy); });
  ctx.stroke();
}
function annotate(text){
  ctx.fillStyle='#222'; ctx.font='12px system-ui';
  ctx.fillText(text, 16, canvas.height/DPR-18);
}

/* ===== Shared render loop ===== */
function drawBackground(){
  if(!bg.img) return;
  const w=canvas.width/DPR,h=canvas.height/DPR;
  ctx.save();
  ctx.globalAlpha=bg.alpha;
  ctx.translate(w/2 + bg.offX, h/2 + bg.offY);
  ctx.rotate(bg.rot);
  ctx.scale(bg.scale, bg.scale);
  ctx.drawImage(bg.img, -bg.img.width/2, -bg.img.height/2);
  ctx.restore();
}

let last=0;
function render(t){
  if(t-last<14){ requestAnimationFrame(render); return; }
  last=t;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round';

  if(ui.mode.value==='architect2d'){
    drawBackground();
    drawGrid();
    // draw sketch
    ctx.lineWidth=+ui.stroke2d.value; ctx.strokeStyle='#111'; ctx.fillStyle='#111';
    sketch.forEach(d=>{
      if(d.type==='seg'){
        ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke();
        if(d.wall>0){
          const nx = d.b.y-d.a.y, ny=-(d.b.x-d.a.x); const L=Math.hypot(nx,ny)||1; const ux=nx/L, uy=ny/L, t=d.wall/2;
          ctx.beginPath(); ctx.moveTo(d.a.x+ux*t,d.a.y+uy*t); ctx.lineTo(d.b.x+ux*t,d.b.y+uy*t); ctx.lineTo(d.b.x-ux*t,d.b.y-uy*t); ctx.lineTo(d.a.x-ux*t,d.a.y-uy*t); ctx.closePath(); ctx.stroke();
        }
      }
      if(d.type==='arc'){ ctx.beginPath(); ctx.arc(d.c.x,d.c.y,d.r,d.a1,d.a2,d.ccw||false); ctx.stroke(); }
      if(d.type==='circ'){ ctx.beginPath(); ctx.arc(d.c.x,d.c.y,d.r,0,Math.PI*2); ctx.stroke(); }
      if(d.type==='door'){ // small arc swing
        ctx.strokeStyle='#0077ff'; ctx.beginPath(); ctx.arc(d.c.x,d.c.y,18,0,Math.PI/2,false); ctx.stroke(); ctx.strokeStyle='#111';
      }
      if(d.type==='window'){
        ctx.strokeStyle='#00aa66'; ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke(); ctx.strokeStyle='#111';
      }
      if(d.type==='dim'){
        ctx.strokeStyle='#cc0000'; ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke();
        const mx=(d.a.x+d.b.x)/2, my=(d.a.y+d.b.y)/2; ctx.fillStyle='#cc0000'; ctx.font='12px system-ui'; ctx.fillText(d.text||'', mx+4, my-4); ctx.strokeStyle='#111'; ctx.fillStyle='#111';
      }
      if(d.type==='label'){ ctx.fillStyle='#333'; ctx.font='14px system-ui'; ctx.fillText(d.text||'Room', d.p.x, d.p.y); ctx.fillStyle='#111'; }
    });
    // hover dot
    if(hoverPoint){ ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(hoverPoint.x,hoverPoint.y,2,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#111'; }
    // HUD
    ctx.fillStyle='#222'; ctx.font='12px system-ui';
    ctx.fillText('2D Architect: Walls/Doors/Windows/Dimensions • SVG export • Photo calibration • View locked', 16, canvas.height/DPR-18);
  } else {
    // Simulation Tutor
    const tDef = topics[ui.topic.value]; if(!tDef){ ctx.restore(); requestAnimationFrame(render); return; }
    const p=getParams(); const ans = tDef.compute ? tDef.compute(p) : {};
    if(tDef.draw) tDef.draw(p,ans,t);
  }

  ctx.restore();
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
} // end startApp
</script>
</body>
</html>
