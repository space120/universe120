<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Universe120 ‚Äî Bubble Graph Builder + 3D</title>
<link rel="icon" href="assets/favicon.svg" type="image/svg+xml">
<style>
:root{
  --bg:#0d2a55; --card:#0f356d; --ink:#fff; --muted:#d8e7ff99; --border:#1e4d9a; --brand:#ffe36a;
  --toolbar:#10366f;
}
*{box-sizing:border-box} html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}

/* NAV */
.navbar{position:fixed;inset:0 0 auto 0;height:56px;z-index:60;display:flex;align-items:center;gap:12px;background:#0f356d;color:#fff;border-bottom:1px solid var(--border);padding:8px 12px}
.brand{display:flex;align-items:center;gap:10px;font-weight:800;color:#fff;text-decoration:none}
.brand .mark{width:26px;height:26px;border-radius:6px;background:#123b79;box-shadow:inset 0 0 0 2px #204c96,0 0 0 1px #092659}
.navlinks{margin-left:auto;display:flex;gap:8px;flex-wrap:wrap}
.navlinks a{color:#fff;text-decoration:none;border:1px solid #204c96;background:#10366f;padding:7px 12px;border-radius:10px;font-size:13px}
.navlinks a:hover{background:#13407f}
.navlinks a.active{outline:2px solid var(--brand)}

/* Top action bar */
.topbar{position:fixed;left:0;right:0;top:56px;z-index:50;display:flex;flex-wrap:wrap;align-items:center;gap:10px;padding:8px 12px;background:var(--toolbar);border-bottom:1px solid var(--border)}
.group{display:flex;gap:6px;align-items:center;background:#0d2e5f;border:1px solid var(--border);border-radius:10px;padding:4px 6px}
label.small{font-size:12px;color:#eaf1ff}
button,.btn,select,input[type="text"],input[type="number"]{appearance:none;border:1px solid #204c96;background:#10366f;color:#fff;border-radius:10px;padding:8px 10px;font-size:13px;cursor:pointer}
button:hover,.btn:hover{background:#13407f}
input[type="text"],input[type="number"],select{padding:6px 8px}
input[type="range"]{accent-color:var(--brand)}

/* Tools drop-down */
.tools-flyout{position:fixed;left:12px;top:120px;z-index:40;background:#0f356d;border:1px solid var(--border);border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.2);width:220px;padding:8px;user-select:none}
.tools-header{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:6px}
.tools-title{font-size:13px;font-weight:700;color:#fff}
.tools-toggle{font-size:12px;padding:4px 8px}
.tools-grid{display:none;grid-template-columns:1fr;gap:6px}
.tools-grid.open{display:grid}
.toolBtn{display:flex;align-items:center;gap:8px;padding:8px 10px;border:1px solid #204c96;border-radius:10px;background:#10366f;color:#fff;font-size:13px}
.toolBtn .icon{width:18px;text-align:center}
.toolBtn.active{outline:2px solid var(--brand)}

/* Properties */
.panel{position:fixed;right:12px;top:56px;transform:translateY(56px);z-index:28;background:#0f356d;border:1px solid var(--border);border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.2);padding:10px 12px;min-width:260px;color:#eaf1ff}
.panel h3{margin:.3rem 0 .2rem;font-size:14px}
.panel .row{display:flex;align-items:center;gap:8px;margin:.35rem 0}

/* 3D viewer panel */
#view3d{position:fixed;right:12px;top:120px;bottom:40px;width:min(46vw,720px);border:1px solid var(--border);border-radius:12px;background:#0f356d;z-index:25;display:flex;flex-direction:column}
#view3d header{display:flex;gap:8px;padding:8px;border-bottom:1px solid var(--border)}
#threeMount{flex:1;min-height:180px}

/* Canvas & overlays */
#canvas{position:fixed;left:0;right:0;top:56px;bottom:28px;display:block;width:100%;height:calc(100% - 84px)}
#overlay{position:fixed;left:0;right:0;top:56px;bottom:28px;pointer-events:none}
.status{position:fixed;left:0;right:0;bottom:0;height:28px;z-index:30;display:flex;align-items:center;gap:16px;padding:0 10px;background:#0f356d;color:#fff;border-top:1px solid var(--border);font-size:12px}

/* Smart-guide badges & rotate handle */
.badge{position:absolute;padding:2px 6px;font-size:12px;color:#001327;background:rgba(255,227,106,.95);border-radius:6px;border:1px solid #e6c84f;white-space:nowrap;user-select:none;z-index:41;transform:translate(-50%,-100%);pointer-events:none}
.badge.alt{background:rgba(124,255,124,.95);border-color:#57db57}
.handle{position:absolute;width:12px;height:12px;border-radius:50%;background:#ffe36a;border:2px solid #0d2a55;box-shadow:0 0 0 1px #204c96;transform:translate(-50%,-50%);z-index:42;cursor:grab}

/* Passcode lock */
#lockScreen{position:fixed;inset:0;background:#0d2a55;color:#fff;display:flex;align-items:center;justify-content:center;z-index:1000;flex-direction:column}
#lockScreen .card{background:#0f356d;border:1px solid var(--border);border-radius:12px;padding:18px;width:min(92vw,440px);box-shadow:0 12px 28px rgba(0,0,0,.25)}
#lockScreen input{width:100%;margin-top:8px;background:#10366f;color:#fff;border:1px solid #204c96;border-radius:10px;padding:10px 12px;font-size:16px}
#lockScreen button{margin-top:10px;padding:10px 12px;font-size:16px}
#lockMsg{margin-top:10px;color:#ff8a8a;min-height:1.2em}

/* Small screens */
@media (max-width: 1060px){
  #view3d{width:44vw}
  .panel{display:none}
}
@media (max-width: 900px){
  #view3d{position:static;width:100%;height:40vh;margin:120px 12px 48px}
}
</style>
</head>
<body>

<!-- PASSCODE (soft gate) -->
<div id="lockScreen">
  <div class="card">
    <h2 style="margin:.2rem 0 .5rem">Universe120 Beta</h2>
    <p style="margin:0 0 .5rem">Enter access code to continue.</p>
    <input type="password" id="accessCodeInput" placeholder="Access code">
    <button id="accessCodeBtn">Enter</button>
    <div id="lockMsg"></div>
    <p style="margin-top:12px;font-size:12px;color:#cfe0ff">
      Open beta ‚Äî ideas/bugs: <a style="color:#ffe36a" href="mailto:120spaceproject@gmail.com">120spaceproject@gmail.com</a>
    </p>
  </div>
</div>

<!-- NAV -->
<div class="navbar">
  <a class="brand" href="index.html" aria-label="Universe120 Home">
    <span class="mark" aria-hidden="true"></span><span>Universe120</span>
  </a>
  <div class="navlinks">
    <a class="active" href="index.html">Home</a>
    <a href="about.html">About</a>
    <a href="mailto:120spaceproject@gmail.com">Email</a>
  </div>
</div>

<!-- TOPBAR -->
<div class="topbar">
  <div class="group">
    <button id="newDoc">New</button>
    <button id="clearAll">Clear</button>
    <button id="undoBtn">Undo</button>
    <button id="redoBtn">Redo</button>
  </div>
  <div class="group">
    <button id="zoomIn">+</button>
    <button id="zoomOut">‚àí</button>
    <button id="zoomFit">Fit</button>
    <button id="zoomReset">100%</button>
  </div>
  <div class="group">
    <label class="small">Grid</label><input id="gridScale" type="range" min="0.6" max="1.8" step="0.01" value="1.0">
    <label class="small">Dots</label><input id="dotSize" type="range" min="0.5" max="1.8" step="0.05" value="1.0">
  </div>
  <div class="group">
    <label class="small">Snap</label>
    <select id="snapMode">
      <option value="intersections" selected>Intersections</option>
      <option value="centers">Centers</option>
      <option value="midpoints">Midpoints</option>
      <option value="free">Free</option>
    </select>
    <label class="small">Angle</label>
    <select id="angleLock">
      <option value="off">Off</option>
      <option value="ortho">0/90¬∞</option>
      <option value="thirty" selected>30/60/90¬∞</option>
      <option value="fortyfive">45/90¬∞</option>
    </select>
  </div>

  <div class="group">
    <label class="small">Floor</label>
    <select id="floorSel"></select>
    <button id="addFloor">+ Floor</button>
    <label class="small">Floor Height</label>
    <input id="floorH" type="number" value="300" step="10" style="width:80px">
  </div>

  <div class="group">
    <button id="groupBtn">Group</button>
    <button id="ungroupBtn">Ungroup</button>
  </div>

  <div class="group">
    <button id="exportSVG">Export SVG</button>
    <button id="exportPNG">Export PNG</button>
    <button id="exportGLTF">Export glTF</button>
  </div>
</div>

<!-- TOOLS -->
<div class="tools-flyout" id="toolsFlyout" aria-label="Tools">
  <div class="tools-header">
    <div class="tools-title">Tools</div>
    <button id="toolsToggle" class="tools-toggle" type="button">Open</button>
  </div>
  <div id="toolsGrid" class="tools-grid">
    <button class="toolBtn" data-tool="select"><span class="icon">üñ±Ô∏è</span><span>Select</span></button>
    <button class="toolBtn" data-tool="pen"><span class="icon">‚úèÔ∏è</span><span>Polyline</span></button>
    <button class="toolBtn" data-tool="line"><span class="icon">‚éØ</span><span>Line</span></button>
    <button class="toolBtn" data-tool="rect"><span class="icon">‚ñ≠</span><span>Rectangle</span></button>
    <button class="toolBtn" data-tool="arc"><span class="icon">‚åí</span><span>Arc</span></button>
    <button class="toolBtn" data-tool="circ"><span class="icon">‚óØ</span><span>Circle</span></button>
    <button class="toolBtn" data-tool="opening"><span class="icon">‚ñ≠</span><span>Opening (Door/Window)</span></button>
    <button class="toolBtn" data-tool="text"><span class="icon">T</span><span>Text</span></button>
    <button class="toolBtn" data-tool="dim"><span class="icon">‚áÑ</span><span>Dimension</span></button>
    <button class="toolBtn" data-tool="erase"><span class="icon">‚å´</span><span>Erase</span></button>
  </div>
</div>

<!-- PROPERTIES -->
<div class="panel" id="props" style="top:56px; margin-top:56px;">
  <h3>Properties</h3>
  <div class="row"><label class="small">Stroke</label><input id="strokeW" type="range" min="0.8" max="4" step="0.1" value="1.6"></div>
  <div class="row"><label class="small">Wall (px)</label><input id="wallThick" type="number" value="10" min="0" max="120" step="1"></div>
  <div class="row"><label class="small">Label</label><input id="labelText" type="text" placeholder="Room / Note"></div>
</div>

<!-- 3D VIEWER -->
<div id="view3d">
  <header>
    <button id="rebuild3D">Rebuild 3D</button>
    <label style="display:inline-flex;align-items:center;gap:6px;color:#fff">
      <input id="wfToggle" type="checkbox" checked/> Wireframe
    </label>
    <label style="display:inline-flex;align-items:center;gap:6px;color:#fff">
      Wall Height <input id="wallH" type="number" value="300" step="10" style="width:80px"/>
    </label>
    <button id="isoBtn">Iso</button>
    <button id="topBtn">Top</button>
    <button id="frontBtn">Front</button>
  </header>
  <div id="threeMount"></div>
</div>

<!-- CANVAS + OVERLAY -->
<canvas id="canvas"></canvas>
<div id="overlay"></div>

<!-- STATUS -->
<div class="status">
  <div id="stTool">Tool: Select</div>
  <div id="stSnap">Snap: Intersections</div>
  <div id="stZoom">Zoom: 100%</div>
  <div id="stPos">x:‚Äì y:‚Äì</div>
  <div id="stInfo"></div>
</div>

<!-- libs: Three, controls, exporter, simple CSG -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/exporters/GLTFExporter.js"></script>
<script src="https://unpkg.com/three-csgmesh@1.0.6/build/three-csgmesh.umd.js"></script>

<script>
/* -------------------- PASSCODE -------------------- */
const VALID_CODE="@@U120";
const lockEl=document.getElementById('lockScreen');
document.getElementById('accessCodeBtn').onclick=()=>{const v=document.getElementById('accessCodeInput').value.trim(); if(v===VALID_CODE) lockEl.style.display='none'; else document.getElementById('lockMsg').textContent='Incorrect code.';};
document.getElementById('accessCodeInput').addEventListener('keydown',e=>{if(e.key==='Enter')document.getElementById('accessCodeBtn').click();});

/* -------------------- DOM/CANVAS -------------------- */
const $=q=>document.querySelector(q), all=q=>[...document.querySelectorAll(q)];
const canvas=$('#canvas'), overlay=$('#overlay'); const ctx=canvas.getContext('2d',{alpha:true});
let DPR=Math.min(devicePixelRatio||1,2);
function resize(){ const w=innerWidth, h=innerHeight-56-28; canvas.width=Math.round(w*DPR); canvas.height=Math.round(h*DPR); canvas.style.width=w+'px'; canvas.style.height=h+'px'; overlay.style.left=0; overlay.style.top='56px'; overlay.style.right=0; overlay.style.bottom='28px'; ctx.setTransform(DPR,0,0,DPR,0,0); }
addEventListener('resize',resize); resize();

/* -------------------- STATE -------------------- */
const stTool=$('#stTool'), stSnap=$('#stSnap'), stZoom=$('#stZoom'), stPos=$('#stPos'), stInfo=$('#stInfo');
const state={
  tool:'select', zoom:1, pan:{x:0,y:0},
  gridScale:1.0, dotScale:1.0,
  strokeW:1.6, wallThick:10,
  snap:'intersections', angleLock:'thirty',
  drawing:null, hover:null,
  shapes:[], selection:new Set(),
  floors:[{id:0,name:'Floor 1'}], activeFloor:0, floorH:300,
  undo:[], redo:[],
  rotation:{active:false,startAng:0,center:null,base:[]}
};
const Rbase=26; function grid(){ const R=Rbase*state.gridScale; return {R,stepX:R, stepY:R*Math.sqrt(3)/2}; }
let lastMouse={x:canvas.width/DPR/2,y:canvas.height/DPR/2};
let mouseDown=false, panning=false, isSpace=false, middlePanning=false;

/* -------------------- UI WIRING -------------------- */
function refreshFloorsUI(){
  const sel=$('#floorSel'); sel.innerHTML='';
  state.floors.forEach(f=>{ const o=document.createElement('option'); o.value=f.id; o.textContent=f.name; if(f.id===state.activeFloor) o.selected=true; sel.appendChild(o); });
}
refreshFloorsUI();
$('#addFloor').onclick=()=>{ const id=Math.max(...state.floors.map(f=>f.id))+1; state.floors.push({id,name:'Floor '+(state.floors.length+1)}); refreshFloorsUI(); };
$('#floorSel').onchange=e=>{ state.activeFloor=+e.target.value; };
$('#floorH').onchange=e=>{ state.floorH=+e.target.value||300; };

$('#gridScale').oninput=e=>state.gridScale=+e.target.value;
$('#dotSize').oninput=e=>state.dotScale=+e.target.value;
$('#snapMode').onchange=e=>{ state.snap=e.target.value; stSnap.textContent='Snap: '+e.target.selectedOptions[0].textContent; };
$('#angleLock').onchange=e=>state.angleLock=e.target.value;
$('#strokeW').oninput=e=>state.strokeW=+e.target.value;
$('#wallThick').oninput=e=>state.wallThick=+e.target.value;
$('#labelText').oninput=e=>state.labelDraft=e.target.value;

$('#zoomIn').onclick=()=>zoomAt(1.1,lastMouse);
$('#zoomOut').onclick=()=>zoomAt(1/1.1,lastMouse);
$('#zoomReset').onclick=()=>{state.zoom=1;state.pan={x:0,y:0};stZoom.textContent='Zoom: 100%';};
$('#zoomFit').onclick=()=>zoomToFit();

$('#newDoc').onclick=()=>{ pushUndo(); state.shapes.length=0; state.selection.clear(); };
$('#clearAll').onclick=()=>{ pushUndo(); state.shapes.length=0; state.selection.clear(); };
$('#undoBtn').onclick=undo; $('#redoBtn').onclick=redo;

$('#exportSVG').onclick=exportSVG;
$('#exportPNG').onclick=exportPNG;

/* tools drop */
$('#toolsToggle').onclick=()=>{ const open=$('#toolsGrid').classList.toggle('open'); $('#toolsToggle').textContent=open?'Close':'Open'; };
$('#toolsGrid').addEventListener('click',e=>{ const btn=e.target.closest('.toolBtn'); if(!btn) return; setTool(btn.dataset.tool); });
function setTool(name){ state.tool=name; state.drawing=null; stTool.textContent='Tool: '+name[0].toUpperCase()+name.slice(1); all('.toolBtn').forEach(el=>el.classList.toggle('active',el.dataset.tool===name)); }

/* -------------------- COORDS -------------------- */
function toWorld(sx,sy){ return {x:(sx-canvas.width/DPR/2-state.pan.x)/state.zoom, y:(sy-canvas.height/DPR/2-state.pan.y)/state.zoom}; }
function toScreen(x,y){ return {x:canvas.width/DPR/2+state.pan.x+x*state.zoom, y:canvas.height/DPR/2+state.pan.y+y*state.zoom}; }

/* -------------------- SMART GUIDES (badges) -------------------- */
const GUIDE={tolLenRatio:0.015,tolAngRad:Math.PI/180*2,niceAngles:[0,Math.PI/6,Math.PI/4,Math.PI/3,Math.PI/2,2*Math.PI/3,3*Math.PI/4,Math.PI]};
function segLen(a,b){return Math.hypot(b.x-a.x,b.y-a.y)} function segAng(a,b){return Math.atan2(b.y-a.y,b.x-a.x)}
let badgePool=[]; function clearBadges(){ badgePool.forEach(el=>el.remove()); badgePool.length=0; }
function placeBadge(pt,text,variant='info'){ if(badgePool.length>=2) return; const el=document.createElement('div'); el.className='badge'+(variant==='good'?' alt':''); el.style.left=pt.x+'px'; el.style.top=(pt.y- (badgePool.length*18))+'px'; el.textContent=text; overlay.appendChild(el); badgePool.push(el); }
function nearLen(L1,L2,rel=GUIDE.tolLenRatio){ return Math.abs(L1-L2)<=Math.max(1e-6,rel*Math.max(L1,L2)); }
function normAng(a){let x=a%(2*Math.PI); if(x<0) x+=2*Math.PI; return x;} function minAngDelta(a,b){const d=Math.abs(normAng(a)-normAng(b));return Math.min(d,2*Math.PI-d);} function nearAng(a,b,tol=GUIDE.tolAngRad){return minAngDelta(a,b)<=tol;}
function getPrevEdge(){ if(state.drawing?.type==='tempPoly'&&state.drawing.points.length>=2){const p=state.drawing.points;return{A:p[p.length-2],B:p[p.length-1]};} for(let i=state.shapes.length-1;i>=0;i--){const s=state.shapes[i]; if(s.type==='seg')return{A:s.a,B:s.b}; if(s.type==='rect')return{A:s.a,B:{x:s.b.x,y:s.a.y}};} return null;}
function drawSmartGuidesHook(){ clearBadges(); if(!state.drawing||!state.hover?.screen) return; const h=state.hover; const prev=getPrevEdge(); function annot(A,B,screen){ const L=segLen(A,B), ang=segAng(A,B); placeBadge(screen,`${L.toFixed(1)}`); for(const na of GUIDE.niceAngles){ if(nearAng(ang,na)){ placeBadge(screen,`${Math.round(na*180/Math.PI)}¬∞`,'good'); break; } } if(prev){ const Lp=segLen(prev.A,prev.B), Ap=segAng(prev.A,prev.B); if(nearLen(L,Lp)) placeBadge(screen,'‚â° equal','good'); else if(nearAng(ang,Ap)) placeBadge(screen,'‚à• parallel','good'); else if(nearAng(ang,Ap+Math.PI/2)) placeBadge(screen,'‚ä• perp','good'); } }
  if(state.drawing.type==='tempLine'){annot(state.drawing.A,h,h.screen);}
  else if(state.drawing.type==='tempPoly'){const pts=state.drawing.points;if(pts.length){const A=pts[pts.length-1];const L=applyAngleLock(A,h);annot(A,L,toScreen(L.x,L.y));}}
  else if(state.drawing.type==='tempRect'){const A=state.drawing.A,B=h;const w=Math.abs(B.x-A.x),ht=Math.abs(B.y-A.y); if(nearLen(w,ht)) placeBadge(toScreen((A.x+B.x)/2,(A.y+B.y)/2),'‚ñ° square','good');}
}

/* -------------------- GRID & SNAPPING -------------------- */
function gridCentersNear(x,y,range=3){ const {stepX,stepY}=grid(); const rr=Math.round(y/stepY), cc=Math.round((x-(rr%2? stepX/2:0))/stepX); const pts=[]; for(let dr=-range;dr<=range;dr++) for(let dc=-range;dc<=range;dc++){ const r=rr+dr,c=cc+dc,gx=c*stepX+(r%2? stepX/2:0), gy=r*stepY; pts.push({x:gx,y:gy,kind:'center'});} const mids=[]; for(let i=0;i<pts.length;i++) for(let j=i+1;j<pts.length;j++){ const a=pts[i],b=pts[j]; if(Math.hypot(a.x-b.x,a.y-b.y)<stepX*1.02) mids.push({x:(a.x+b.x)/2,y:(a.y+b.y)/2,kind:'mid'});} return pts.concat(mids); }
function snapPoint(x,y,strong=false){ if(state.snap==='free') return {x,y,kind:'free'}; const cand=gridCentersNear(x,y,strong?4:3); let best=null,bd=1e9; cand.forEach(p=>{const d2=(p.x-x)*(p.x-x)+(p.y-y)*(p.y-y); if(d2<bd){bd=d2;best=p;}}); return best||{x,y,kind:'free'}; }
function shapeAnchors(s){ const pts=[]; if(s.type==='seg'){pts.push(s.a,s.b);} if(s.type==='rect'||s.type==='opening'){pts.push(s.a,{x:s.b.x,y:s.a.y},s.b,{x:s.a.x,y:s.b.y});} if(s.type==='arc'){pts.push({x:s.c.x+s.r*Math.cos(s.a1),y:s.c.y+s.r*Math.sin(s.a1)},{x:s.c.x+s.r*Math.cos(s.a2),y:s.c.y+s.r*Math.sin(s.a2)},s.c);} if(s.type==='circ'){pts.push(s.c);} if(s.type==='dim'){pts.push(s.a,s.b);} if(s.type==='label'){pts.push(s.p);} return pts; }
function sceneSnapCandidates(excludeSet){ const pts=[]; state.shapes.forEach((s,i)=>{ if(!excludeSet?.has(i) && s.floor===state.activeFloor) pts.push(...shapeAnchors(s));}); return pts; }
function snapWorld(x,y,strong,excludeSet){ if(state.snap==='free') return {x,y}; const gridPts=gridCentersNear(x,y,strong?4:3); const objPts=sceneSnapCandidates(excludeSet); let best={x,y},bd=1e9; function test(px,py){const d2=(px-x)*(px-x)+(py-y)*(py-y); if(d2<bd){bd=d2;best={x:px,y:py};}} gridPts.forEach(p=>test(p.x,p.y)); objPts.forEach(p=>test(p.x,p.y)); return best; }

/* -------------------- Angle lock -------------------- */
function applyAngleLock(a0,a1){ const mode=state.angleLock; if(mode==='off') return a1; const dx=a1.x-a0.x, dy=a1.y-a0.y, ang=Math.atan2(dy,dx); let snaps=[]; if(mode==='ortho') snaps=[0,Math.PI/2,Math.PI,3*Math.PI/2]; else if(mode==='thirty') snaps=[0,Math.PI/6,Math.PI/3,Math.PI/2,2*Math.PI/3,5*Math.PI/6,Math.PI,7*Math.PI/6,4*Math.PI/3,3*Math.PI/2,5*Math.PI/3,11*Math.PI/6]; else if(mode==='fortyfive') snaps=[0,Math.PI/4,Math.PI/2,3*Math.PI/4,Math.PI,5*Math.PI/4,3*Math.PI/2,7*Math.PI/4]; let best=ang,bd=1e9; snaps.forEach(s=>{const d=Math.abs(((ang-s+Math.PI)%(2*Math.PI))-Math.PI); if(d<bd){bd=d;best=s;}}); const len=Math.hypot(dx,dy); return {x:a0.x+Math.cos(best)*len, y:a0.y+Math.sin(best)*len}; }

/* -------------------- UNDO -------------------- */
function pushUndo(){ state.undo.push(JSON.stringify({shapes:state.shapes})); state.redo.length=0; }
function undo(){ if(!state.undo.length) return; const cur=JSON.stringify({shapes:state.shapes}); const prev=state.undo.pop(); state.redo.push(cur); state.shapes=JSON.parse(prev).shapes; state.selection.clear(); }
function redo(){ if(!state.redo.length) return; const cur=JSON.stringify({shapes:state.shapes}); const next=state.redo.pop(); state.undo.push(cur); state.shapes=JSON.parse(next).shapes; state.selection.clear(); }

/* -------------------- SHAPES (floor-aware) -------------------- */
function withFloor(obj){ return Object.assign(obj,{floor:state.activeFloor}); }
function finishLine(B){ const A=state.drawing.A; const L=applyAngleLock(A,B); state.shapes.push(withFloor({type:'seg',a:A,b:L,wall:state.wallThick||0})); state.drawing=null; }
function finishRect(B,kind='rect'){ const A=state.drawing.A; state.shapes.push(withFloor({type:kind,a:{x:Math.min(A.x,B.x),y:Math.min(A.y,B.y)},b:{x:Math.max(A.x,B.x),y:Math.max(A.y,B.y)},wall:state.wallThick||0})); state.drawing=null; }
function finishArc(B){ const A=state.drawing.A; const C={x:(A.x+B.x)/2,y:(A.y+B.y)/2}; const r=Math.hypot(B.x-A.x,B.y-A.y)/2; const a1=Math.atan2(A.y-C.y,A.x-C.x), a2=Math.atan2(B.y-C.y,B.x-C.x); state.shapes.push(withFloor({type:'arc',c:C,r,a1,a2})); state.drawing=null; }
function finishCirc(B){ const A=state.drawing.A; const r=Math.hypot(B.x-A.x,B.y-A.y); state.shapes.push(withFloor({type:'circ',c:A,r})); state.drawing=null; }
function finishDim(B){ const A=state.drawing.A; const len=Math.hypot(B.x-A.x,B.y-A.y); state.shapes.push(withFloor({type:'dim',a:A,b:B,text:`${len.toFixed(1)}`})); state.drawing=null; }
function finalizePolyline(){ const pts=state.drawing.points; if(pts.length>=2){ for(let i=0;i<pts.length-1;i++){ state.shapes.push(withFloor({type:'seg',a:pts[i],b:pts[i+1],wall:state.wallThick||0})); } } state.drawing=null; }

/* -------------------- ERASE -------------------- */
function eraseNearest(P){ let bi=-1, bd=1e9; state.shapes.forEach((d,i)=>{ if(d.floor!==state.activeFloor) return; let cx=0,cy=0; if(d.type==='seg'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;} else if(d.type==='rect'||d.type==='opening'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;} else if(d.type==='arc'){cx=d.c.x;cy=d.c.y;} else if(d.type==='circ'){cx=d.c.x;cy=d.c.y;} else if(d.type==='label'){cx=d.p.x;cy=d.p.y;} else if(d.type==='dim'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;} const d2=(P.x-cx)*(P.x-cx)+(P.y-cy)*(P.y-cy); if(d2<bd){bd=d2;bi=i;} }); if(bi>=0) state.shapes.splice(bi,1); }

/* -------------------- HIT / SELECT -------------------- */
function distPointSeg(P,A,B){ const vx=B.x-A.x,vy=B.y-A.y; const wx=P.x-A.x,wy=P.y-A.y; const t=Math.max(0,Math.min(1,(vx*wx+vy*wy)/(vx*vx+vy*vy||1))); const dx=(A.x+t*vx)-P.x, dy=(A.y+t*vy)-P.y; return Math.hypot(dx,dy); }
function hitTest(worldP,tol=10/state.zoom){ let best=-1,bd=1e9; state.shapes.forEach((s,i)=>{ if(s.floor!==state.activeFloor) return; let d=1e9; if(s.type==='seg'||s.type==='dim'){ d=distPointSeg(worldP,s.a,s.b); } else if(s.type==='rect'||s.type==='opening'){ const minX=Math.min(s.a.x,s.b.x),maxX=Math.max(s.a.x,s.b.x),minY=Math.min(s.a.y,s.b.y),maxY=Math.max(s.a.y,s.b.y); const nearX=Math.min(Math.abs(worldP.x-minX),Math.abs(worldP.x-maxX)); const nearY=Math.min(Math.abs(worldP.y-minY),Math.abs(worldP.y-maxY)); d=Math.min(nearX,nearY);} else if(s.type==='circ'){ d=Math.abs(Math.hypot(worldP.x-s.c.x,worldP.y-s.c.y)-s.r);} else if(s.type==='arc'){ const R=Math.hypot(worldP.x-s.c.x,worldP.y-s.c.y); d=Math.abs(R-s.r);} else if(s.type==='label'){ d=Math.hypot(worldP.x-s.p.x,worldP.y-s.p.y);} if(d<bd){bd=d;best=i;} }); return (bd<=tol)?best:-1; }
function centerOfSelection(){ if(!state.selection.size) return null; let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9; function include(x,y){minX=Math.min(minX,x);minY=Math.min(minY,y);maxX=Math.max(maxX,x);maxY=Math.max(maxY,y);} state.selection.forEach(i=>shapeAnchors(state.shapes[i]).forEach(p=>include(p.x,p.y))); return {x:(minX+maxX)/2,y:(minY+maxY)/2,box:{minX,minY,maxX,maxY}}; }

/* group / ungroup */
$('#groupBtn').onclick=()=>{ if(state.selection.size<2) return; const gid=Date.now(); state.selection.forEach(i=>state.shapes[i].gid=gid); };
$('#ungroupBtn').onclick=()=>{ state.selection.forEach(i=>delete state.shapes[i].gid); };

/* -------------------- EVENTS -------------------- */
let dragSel=null;
canvas.addEventListener('mousemove',e=>{
  lastMouse={x:e.clientX,y:e.clientY};
  const w=toWorld(e.clientX,e.clientY);
  const snapped=snapPoint(w.x,w.y,false);
  state.hover={...snapped,screen:toScreen(snapped.x,snapped.y)};
  stPos.textContent=`x:${snapped.x.toFixed(1)} y:${snapped.y.toFixed(1)}`;

  if(panning||middlePanning){ state.pan.x+=e.movementX; state.pan.y+=e.movementY; }

  if(dragSel && !state.rotation.active){
    const now=toWorld(e.clientX,e.clientY);
    const dx=now.x-dragSel.startMouse.x, dy=now.y-dragSel.startMouse.y;
    const ref={x:dragSel.ref.x+dx, y:dragSel.ref.y+dy};
    const snappedRef=snapWorld(ref.x,ref.y,e.shiftKey,state.selection);
    const snapDx=snappedRef.x-dragSel.ref0.x, snapDy=snappedRef.y-dragSel.ref0.y;
    state.selection.forEach(idx=>{
      const base=dragSel.base.find(b=>b.i===idx).s;
      const moved=JSON.parse(JSON.stringify(base));
      const shift=p=>{ p.x+=snapDx; p.y+=snapDy; };
      if(moved.type==='seg'){shift(moved.a);shift(moved.b);}
      if(moved.type==='rect'||moved.type==='opening'){shift(moved.a);shift(moved.b);}
      if(moved.type==='arc'){shift(moved.c);}
      if(moved.type==='circ'){shift(moved.c);}
      if(moved.type==='dim'){shift(moved.a);shift(moved.b);}
      if(moved.type==='label'){shift(moved.p);}
      state.shapes[idx]=moved;
    });
  }
});
canvas.addEventListener('mousedown',e=>{
  if(e.button===1){middlePanning=true;return;}
  if(e.button===2) return;
  mouseDown=true;
  if(isSpace){ panning=true; return; }

  const w=toWorld(e.clientX,e.clientY);
  if(state.tool==='select'){
    const idx=hitTest(w);
    if(idx>=0){
      if(e.shiftKey){ if(state.selection.has(idx)) state.selection.delete(idx); else state.selection.add(idx); }
      else{ state.selection=new Set([idx]); }
      const anchors=shapeAnchors(state.shapes[idx]); let ref=anchors[0],bd=1e9; anchors.forEach(p=>{const d2=(p.x-w.x)*(p.x-w.x)+(p.y-w.y)*(p.y-w.y); if(d2<bd){bd=d2;ref=p;}});
      dragSel={ref:{x:w.x,y:w.y},ref0:{x:ref.x,y:ref.y},startMouse:w,base:[...state.selection].map(i=>({i,s:JSON.parse(JSON.stringify(state.shapes[i]))}))};
      return;
    }else{ state.selection.clear(); }
  }

  // start drawing
  pushUndo();
  const P=snapPoint(w.x,w.y,e.shiftKey);
  const t=state.tool;
  if(t==='line'){ state.drawing=state.drawing?(finishLine(P)):{type:'tempLine',A:P}; }
  else if(t==='pen'){ if(!state.drawing) state.drawing={type:'tempPoly',points:[P]}; else{const pts=state.drawing.points; const A=pts[pts.length-1]; const L=applyAngleLock(A,P); pts.push(L);} }
  else if(t==='arc'){ state.drawing=state.drawing?(finishArc(P)):{type:'tempArc',A:P}; }
  else if(t==='rect'){ state.drawing=state.drawing?(finishRect(P,'rect')):{type:'tempRect',A:P}; }
  else if(t==='opening'){ state.drawing=state.drawing?(finishRect(P,'opening')):{type:'tempRect',A:P}; }
  else if(t==='circ'){ state.drawing=state.drawing?(finishCirc(P)):{type:'tempCirc',A:P}; }
  else if(t==='text'){ const txt=(state.labelDraft||prompt('Text:','Room')||'Note'); state.shapes.push(withFloor({type:'label',p:P,text:txt})); }
  else if(t==='dim'){ state.drawing=state.drawing?(finishDim(P)):{type:'tempDim',A:P}; }
  else if(t==='erase'){ eraseNearest(P); }
});
addEventListener('mouseup',e=>{ if(e.button===1){middlePanning=false;} dragSel=null; mouseDown=false; panning=false; });
canvas.addEventListener('wheel',e=>{ e.preventDefault(); zoomAt(Math.exp(-e.deltaY*0.0018),{x:e.clientX,y:e.clientY}); },{passive:false});
addEventListener('contextmenu',e=>e.preventDefault());
addEventListener('keydown',e=>{
  if(e.code==='Space') isSpace=true;
  if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='z'){e.preventDefault();undo();}
  if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='y'){e.preventDefault();redo();}
  if(e.key==='1'&&e.shiftKey){zoomToFit();}
  else if(e.key==='1'){state.zoom=1;state.pan={x:0,y:0};stZoom.textContent='Zoom: 100%';}
  if(e.key==='Escape'){state.drawing=null; clearBadges();}
  if(e.key==='Enter'&&state.drawing?.type==='tempPoly'){ finalizePolyline(); }
  const map={v:'select',p:'pen',l:'line',a:'arc',r:'rect',o:'circ',t:'text',d:'dim',e:'erase'};
  const k=e.key.toLowerCase(); if(map[k]) setTool(map[k]);
});
addEventListener('keyup',e=>{ if(e.code==='Space') isSpace=false; });

/* rotate handle */
let handleEl=null;
function ensureHandle(){
  if(!state.selection.size){ if(handleEl){handleEl.remove();handleEl=null;} return; }
  const c=centerOfSelection(); if(!c) return;
  const topScreen=toScreen(c.box.minX+(c.box.maxX-c.box.minX)/2,c.box.minY); const yOff=24;
  if(!handleEl){handleEl=document.createElement('div'); handleEl.className='handle'; overlay.appendChild(handleEl);}
  handleEl.style.left=topScreen.x+'px'; handleEl.style.top=(topScreen.y-yOff)+'px';
  handleEl.onmousedown=(e)=>{
    e.preventDefault(); state.rotation.active=true; state.rotation.center={x:c.x,y:c.y};
    state.rotation.startAng=Math.atan2(toWorld(e.clientX,e.clientY).y-c.y,toWorld(e.clientX,e.clientY).x-c.x);
    state.rotation.base=[...state.selection].map(i=>({i,s:JSON.parse(JSON.stringify(state.shapes[i]))}));
  };
}
document.addEventListener('mousemove',e=>{
  if(!state.rotation.active) return;
  const cen=state.rotation.center;
  const curAng=Math.atan2(toWorld(e.clientX,e.clientY).y-cen.y,toWorld(e.clientX,e.clientY).x-cen.x);
  let dAng=curAng-state.rotation.startAng;
  const nice=[0,Math.PI/6,Math.PI/4,Math.PI/3,Math.PI/2,2*Math.PI/3,3*Math.PI/4,Math.PI]; let best=dAng,bd=1e9;
  nice.concat(nice.map(a=>-a)).forEach(a=>{const diff=Math.abs(((dAng-a+Math.PI)%(2*Math.PI))-Math.PI); if(diff<bd){bd=diff;best=a;}});
  if(bd<Math.PI/180*6) dAng=best;
  const sin=Math.sin(dAng), cos=Math.cos(dAng), C=state.rotation.center;
  const rot=p=>({x:C.x+(p.x-C.x)*cos-(p.y-C.y)*sin, y:C.y+(p.x-C.x)*sin+(p.y-C.y)*cos});
  state.rotation.base.forEach(({i,s})=>{ const m=JSON.parse(JSON.stringify(s)); if(m.type==='seg'){m.a=rot(m.a);m.b=rot(m.b);} if(m.type==='rect'||m.type==='opening'){m.a=rot(m.a);m.b=rot(m.b);} if(m.type==='arc'){m.c=rot(m.c);} if(m.type==='circ'){m.c=rot(m.c);} if(m.type==='dim'){m.a=rot(m.a);m.b=rot(m.b);} if(m.type==='label'){m.p=rot(m.p);} state.shapes[i]=m; });
});
document.addEventListener('mouseup',()=>{ if(state.rotation.active) state.rotation.active=false; });

/* -------------------- ZOOM / EXPORT -------------------- */
function zoomAt(factor,pt){ const before=state.zoom, after=Math.max(0.25,Math.min(6,before*factor)); if(after===before) return; const wx=(pt.x-canvas.width/DPR/2-state.pan.x)/before, wy=(pt.y-canvas.height/DPR/2-state.pan.y)/before; state.zoom=after; state.pan.x=pt.x-canvas.width/DPR/2-wx*after; state.pan.y=pt.y-canvas.height/DPR/2-wy*after; stZoom.textContent=`Zoom: ${(state.zoom*100).toFixed(0)}%`; }
function zoomToFit(){ if(!state.shapes.length){state.zoom=1;state.pan={x:0,y:0};stZoom.textContent='Zoom: 100%';return;} let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9; function inc(x,y){minX=Math.min(minX,x);minY=Math.min(minY,y);maxX=Math.max(maxX,x);maxY=Math.max(maxY,y);} state.shapes.filter(s=>s.floor===state.activeFloor).forEach(s=>{ if(s.type==='seg'){inc(s.a.x,s.a.y);inc(s.b.x,s.b.y);} if(s.type==='rect'||s.type==='opening'){inc(s.a.x,s.a.y);inc(s.b.x,s.b.y);} if(s.type==='arc'){inc(s.c.x-s.r,s.c.y-s.r);inc(s.c.x+s.r,s.c.y+s.r);} if(s.type==='circ'){inc(s.c.x-s.r,s.c.y-s.r);inc(s.c.x+s.r,s.c.y+s.r);} if(s.type==='label'){inc(s.p.x,s.p.y);} if(s.type==='dim'){inc(s.a.x,s.a.y);inc(s.b.x,s.b.y);} }); const pad=40,w=canvas.width/DPR,h=canvas.height/DPR; const zw=(w-pad*2)/(maxX-minX||1), zh=(h-pad*2)/(maxY-minY||1); state.zoom=Math.max(0.25,Math.min(6,Math.min(zw,zh))); state.pan.x=-((minX+maxX)/2)*state.zoom; state.pan.y=-((minY+maxY)/2)*state.zoom; stZoom.textContent=`Zoom: ${(state.zoom*100).toFixed(0)}%`; }
function exportPNG(){ const link=document.createElement('a'); link.download='universe120.png'; link.href=canvas.toDataURL('image/png'); link.click(); }
function exportSVG(){ const w=canvas.width/DPR,h=canvas.height/DPR, sw=state.strokeW; const stroke='#ffffff', gridStroke='#ffffff22'; const out=[]; out.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" fill="none" stroke="${stroke}" stroke-width="${sw}">`); const G=grid(); const R=G.R*state.dotScale; const stepX=G.stepX,stepY=G.stepY; out.push(`<g id="grid" stroke="${gridStroke}" stroke-width="0.9">`); for(let r=-30;r<60;r++){for(let c=-30;c<60;c++){const x=c*stepX+(r%2? stepX/2:0), y=r*stepY; const p=toScreen(x,y); out.push(`<circle cx="${p.x.toFixed(1)}" cy="${p.y.toFixed(1)}" r="${(R*state.zoom).toFixed(2)}"/>`);}} out.push(`</g><g id="draw">`); state.shapes.forEach(d=>{ if(d.floor!==state.activeFloor) return; if(d.type==='seg'){const a=toScreen(d.a.x,d.a.y),b=toScreen(d.b.x,d.b.y); out.push(`<line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}"/>`);} if(d.type==='rect'||d.type==='opening'){const a=toScreen(d.a.x,d.a.y),b=toScreen(d.b.x,d.b.y); out.push(`<rect x="${Math.min(a.x,b.x)}" y="${Math.min(a.y,b.y)}" width="${Math.abs(b.x-a.x)}" height="${Math.abs(b.y-a.y)}" ${d.type==='opening'?'stroke="#ffb3b3"':''}/>`);} if(d.type==='arc'){const c=toScreen(d.c.x,d.c.y); const x1=c.x+d.r*state.zoom*Math.cos(d.a1), y1=c.y+d.r*state.zoom*Math.sin(d.a1); const x2=c.x+d.r*state.zoom*Math.cos(d.a2), y2=c.y*d.zoom; out.push(`<path d="M ${x1} ${y1} A ${d.r*state.zoom} ${d.r*state.zoom} 0 0 1 ${x2} ${y2}"/>`);} if(d.type==='circ'){const c=toScreen(d.c.x,d.c.y); out.push(`<circle cx="${c.x}" cy="${c.y}" r="${d.r*state.zoom}"/>`);} if(d.type==='label'){const p=toScreen(d.p.x,d.p.y); out.push(`<text x="${p.x}" y="${p.y}" font-size="14" fill="${stroke}" stroke="none">${(d.text||'Label')}</text>`);} if(d.type==='dim'){const a=toScreen(d.a.x,d.a.y),b=toScreen(d.b.x,d.b.y); out.push(`<line x1="${a.x}" y1="${a.y}" x2="${b.x}" y2="${b.y}" stroke="#cc0000"/>`);} }); out.push(`</g></svg>`); const blob=new Blob([out.join('\n')],{type:'image/svg+xml'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='universe120.svg'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1500); }

/* -------------------- RENDER 2D -------------------- */
function drawGrid(){ const G=grid(); const R=G.R*state.dotScale; const stepX=G.stepX,stepY=G.stepY; const w=canvas.width/DPR,h=canvas.height/DPR; ctx.save(); ctx.translate(w/2+state.pan.x,h/2+state.pan.y); ctx.scale(state.zoom,state.zoom); ctx.lineWidth=0.9/state.zoom; ctx.strokeStyle='#ffffff22'; const cols=Math.ceil(w/(stepX*state.zoom))+4, rows=Math.ceil(h/(stepY*state.zoom))+4; const x0=-((w/2+state.pan.x)/state.zoom); const y0=-((h/2+state.pan.y)/state.zoom); const cStart=Math.floor((x0-2*stepX)/stepX), rStart=Math.floor((y0-2*stepY)/stepY); for(let r=rStart;r<rStart+rows;r++){ for(let c=cStart;c<cStart+cols;c++){ const x=c*stepX+(r%2? stepX/2:0), y=r*stepY; ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.stroke(); } } ctx.restore(); }
function drawShapes(){
  ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round'; ctx.lineWidth=state.strokeW; ctx.strokeStyle='#fff'; ctx.fillStyle='#fff';
  state.shapes.filter(s=>s.floor===state.activeFloor).forEach(s=>{
    if(s.type==='seg'){const a=toScreen(s.a.x,s.a.y),b=toScreen(s.b.x,s.b.y); ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();}
    if(s.type==='rect'){const a=toScreen(s.a.x,s.a.y),b=toScreen(s.b.x,s.b.y); ctx.strokeRect(Math.min(a.x,b.x),Math.min(a.y,b.y),Math.abs(b.x-a.x),Math.abs(b.y-a.y));}
    if(s.type==='opening'){const a=toScreen(s.a.x,s.a.y),b=toScreen(s.b.x,s.b.y); ctx.strokeStyle='#ffb3b3'; ctx.strokeRect(Math.min(a.x,b.x),Math.min(a.y,b.y),Math.abs(b.x-a.x),Math.abs(b.y-a.y)); ctx.strokeStyle='#fff';}
    if(s.type==='arc'){const c=toScreen(s.c.x,s.c.y); ctx.beginPath(); ctx.arc(c.x,c.y,s.r*state.zoom,s.a1,s.a2); ctx.stroke();}
    if(s.type==='circ'){const c=toScreen(s.c.x,s.c.y); ctx.beginPath(); ctx.arc(c.x,c.y,s.r*state.zoom,0,Math.PI*2); ctx.stroke();}
    if(s.type==='label'){const p=toScreen(s.p.x,s.p.y); ctx.font='14px system-ui'; ctx.fillText(s.text||'Label',p.x,p.y);}
    if(s.type==='dim'){const a=toScreen(s.a.x,s.a.y),b=toScreen(s.b.x,s.b.y); ctx.strokeStyle='#cc0000'; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); ctx.strokeStyle='#fff';}
  });
  ctx.setLineDash([6,6]); ctx.strokeStyle='#cbd5ff';
  const h=state.hover?.screen;
  if(state.drawing){
    if(state.drawing.type==='tempLine'&&h){const A=toScreen(state.drawing.A.x,state.drawing.A.y); ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(h.x,h.y); ctx.stroke();}
    if(state.drawing.type==='tempRect'&&h){const A=toScreen(state.drawing.A.x,state.drawing.A.y); ctx.strokeRect(Math.min(A.x,h.x),Math.min(A.y,h.y),Math.abs(h.x-A.x),Math.abs(h.y-A.y));}
    if(state.drawing.type==='tempCirc'&&h){const A=toScreen(state.drawing.A.x,state.drawing.A.y); const r=Math.hypot(h.x-A.x,h.y-A.y); ctx.beginPath(); ctx.arc(A.x,A.y,r,0,Math.PI*2); ctx.stroke();}
    if(state.drawing.type==='tempArc'&&h){const A=toScreen(state.drawing.A.x,state.drawing.A.y); const C={x:(A.x+h.x)/2,y:(A.y+h.y)/2}, r=Math.hypot(h.x-A.x,h.y-A.y)/2; const a1=Math.atan2(A.y-C.y,A.x-C.x),a2=Math.atan2(h.y-C.y,h.x-C.x); ctx.beginPath(); ctx.arc(C.x,C.y,r,a1,a2); ctx.stroke();}
    if(state.drawing.type==='tempPoly'&&h){const pts=state.drawing.points; const A=pts[pts.length-1]; const L=applyAngleLock(A,state.hover); const pA=toScreen(A.x,A.y), pL=toScreen(L.x,L.y); ctx.beginPath(); ctx.moveTo(pA.x,pA.y); ctx.lineTo(pL.x,pL.y); ctx.stroke();}
  }
  ctx.setLineDash([]);
  if(state.hover?.screen){ ctx.fillStyle='#ffe36a'; ctx.beginPath(); ctx.arc(state.hover.screen.x,state.hover.screen.y,3.2,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#fff'; }
  if(state.selection?.size){ let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9; function include(x,y){minX=Math.min(minX,x);minY=Math.min(minY,y);maxX=Math.max(maxX,x);maxY=Math.max(maxY,y);} state.selection.forEach(i=>shapeAnchors(state.shapes[i]).forEach(p=>include(p.x,p.y))); const pad=12/state.zoom; const a=toScreen(minX-pad,minY-pad),b=toScreen(maxX+pad,maxY+pad); ctx.save(); ctx.setLineDash([6,6]); ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--brand')||'#ffe36a'; ctx.strokeRect(a.x,a.y,b.x-a.x,b.y-a.y); ctx.restore(); }
  ctx.restore();
  drawSmartGuidesHook(); ensureHandle(); updateMeasurementsPanel();
}
function frame(){ ctx.clearRect(0,0,canvas.width,canvas.height); drawGrid(); drawShapes(); requestAnimationFrame(frame); } requestAnimationFrame(frame);

/* -------------------- MEASUREMENTS (status info) -------------------- */
function updateMeasurementsPanel(){
  if(state.selection.size!==1){ stInfo.textContent=''; return; }
  const s=state.shapes[[...state.selection][0]];
  let txt='';
  if(s.type==='seg'||s.type==='dim'){ txt=`Len: ${Math.hypot(s.b.x-s.a.x,s.b.y-s.a.y).toFixed(1)}`; }
  if(s.type==='rect'||s.type==='opening'){ const w=Math.abs(s.b.x-s.a.x), h=Math.abs(s.b.y-s.a.y); txt=`W√óH: ${w.toFixed(1)} √ó ${h.toFixed(1)}  Area: ${(w*h).toFixed(1)}`; }
  stInfo.textContent=txt;
}

/* -------------------- THREE.JS VIEWER -------------------- */
let renderer, scene, camera, controls, threeRoot, wfMat, solidMat;
function init3D(){
  threeRoot=document.getElementById('threeMount');
  const w=threeRoot.clientWidth,h=threeRoot.clientHeight;
  renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(w,h); renderer.setPixelRatio(Math.min(devicePixelRatio||1,2)); threeRoot.innerHTML=''; threeRoot.appendChild(renderer.domElement);
  scene=new THREE.Scene(); scene.background=new THREE.Color(0x0f356d);
  camera=new THREE.PerspectiveCamera(45,w/h,0.1,200000); camera.position.set(800,600,800);
  controls=new THREE.OrbitControls(camera,renderer.domElement); controls.enableDamping=true; controls.dampingFactor=0.08; controls.target.set(0,0,0);
  const light=new THREE.DirectionalLight(0xffffff,1.0); light.position.set(500,800,700); scene.add(light,new THREE.AmbientLight(0xffffff,0.35));
  const grid=new THREE.GridHelper(4000,40,0x4a74d8,0x1d3c86); grid.material.opacity=0.35; grid.material.transparent=true; scene.add(grid);
  wfMat=new THREE.MeshBasicMaterial({color:0xffffff,wireframe:true});
  solidMat=new THREE.MeshStandardMaterial({color:0xdfe9ff,metalness:0.1,roughness:0.9});
  animate3D();
}
function animate3D(){ requestAnimationFrame(animate3D); controls?.update(); renderer?.render(scene,camera); }
window.addEventListener('resize',()=>{ if(!renderer) return; const w=threeRoot.clientWidth,h=threeRoot.clientHeight; renderer.setSize(w,h); camera.aspect=w/h; camera.updateProjectionMatrix(); });

/* helpers */
function rectToShape(r){ const minX=Math.min(r.a.x,r.b.x), maxX=Math.max(r.a.x,r.b.x); const minY=Math.min(r.a.y,r.b.y), maxY=Math.max(r.a.y,r.b.y); return new THREE.Shape([ new THREE.Vector2(minX,minY), new THREE.Vector2(maxX,minY), new THREE.Vector2(maxX,maxY), new THREE.Vector2(minX,maxY) ]); }
function polyFromSegments(segments){ // build closed loops (simple)
  const tol=1e-4; const left=segments.map(s=>({a:new THREE.Vector2(s.a.x,s.a.y),b:new THREE.Vector2(s.b.x,s.b.y)}));
  const loops=[];
  function eq(a,b){return Math.abs(a.x-b.x)<tol && Math.abs(a.y-b.y)<tol;}
  while(left.length){
    const start=left.pop(); const loop=[start.a.clone(), start.b.clone()];
    let cur=loop[1];
    for(let i=0;i<10000;i++){
      let fi=-1,flip=false;
      for(let j=0;j<left.length;j++){
        if(eq(left[j].a,cur)){fi=j;flip=false;break;}
        if(eq(left[j].b,cur)){fi=j;flip=true;break;}
      }
      if(fi<0) break;
      const seg=left.splice(fi,1)[0];
      cur = (flip? seg.a : seg.b).clone();
      loop.push(cur.clone());
      if(eq(loop[0],cur)) { loops.push(loop.slice(0,-1)); break; }
    }
  }
  return loops.map(pts=>{ const shape=new THREE.Shape(pts); return shape; });
}

/* openings inclusion: any 'opening' fully inside a rect/poly on same floor becomes a hole */
function shapeContainsRect(shape, op){
  const minX=Math.min(op.a.x,op.b.x), maxX=Math.max(op.a.x,op.b.x);
  const minY=Math.min(op.a.y,op.b.y), maxY=Math.max(op.a.y,op.b.y);
  const poly=shape.getPoints(4);
  function inside(pt){
    let c=false; for(let i=0,j=poly.length-1;i<poly.length;j=i++){
      const xi=poly[i].x, yi=poly[i].y, xj=poly[j].x, yj=poly[j].y;
      const intersect = ((yi>pt.y)!=(yj>pt.y)) && (pt.x < (xj-xi)*(pt.y-yi)/(yj-yi+1e-9)+xi);
      if(intersect) c=!c;
    } return c;
  }
  return inside(new THREE.Vector2(minX,minY)) && inside(new THREE.Vector2(maxX,maxY));
}

function shapesTo3DMeshes(allShapes, wallHeight=300, wire=true){
  const meshes=[];
  const byFloor = {};
  allShapes.forEach(s=>{ (byFloor[s.floor] ||= []).push(s); });

  Object.keys(byFloor).forEach(floorId=>{
    const floor = +floorId;
    const shapes = byFloor[floor];
    const segments = shapes.filter(s=>s.type==='seg');
    const rects    = shapes.filter(s=>s.type==='rect');
    const openings = shapes.filter(s=>s.type==='opening');

    // Rects -> extruded walls (with holes)
    rects.forEach(r=>{
      const sh = rectToShape(r);
      openings.forEach(op=>{ if(shapeContainsRect(sh, op)){ const hole = rectToShape(op).getPoints(4); const path = new THREE.Path(hole); sh.holes.push(path); }});
      const geo = new THREE.ExtrudeGeometry(sh,{depth:wallHeight,bevelEnabled:false});
      geo.rotateX(-Math.PI/2);
      const mesh=new THREE.Mesh(geo, wire? wfMat: solidMat);
      mesh.position.y = floor * state.floorH;
      meshes.push(mesh);
    });

    // Closed polylines (segments) -> extruded
    const loops = polyFromSegments(segments);
    loops.forEach(sh=>{
      const geo=new THREE.ExtrudeGeometry(sh,{depth:wallHeight, bevelEnabled:false});
      geo.rotateX(-Math.PI/2);
      const mesh=new THREE.Mesh(geo, wire? wfMat: solidMat);
      mesh.position.y = floor * state.floorH;
      meshes.push(mesh);
    });
  });

  return meshes;
}

/* build scene */
function clearMeshes(){ [...scene.children].forEach(o=>{ if(o.isMesh){ scene.remove(o); o.geometry.dispose(); } }); }
function rebuild3D(){
  clearMeshes();
  const height=parseFloat($('#wallH').value)||300;
  const wire=$('#wfToggle').checked;
  const meshes=shapesTo3DMeshes(state.shapes,height,wire);
  meshes.forEach(m=>scene.add(m));
  controls?.update();
}
$('#rebuild3D').onclick=rebuild3D;
$('#wfToggle').onchange=rebuild3D;
$('#wallH').onchange=rebuild3D;

/* preset views */
$('#isoBtn').onclick=()=>{ camera.position.set(800,600,800); controls.target.set(0,0,0); controls.update(); };
$('#topBtn').onclick=()=>{ camera.position.set(0,1200,0.001); controls.target.set(0,0,0); controls.update(); };
$('#frontBtn').onclick=()=>{ camera.position.set(0,400,1000); controls.target.set(0,0,0); controls.update(); };

init3D();

/* Export glTF */
$('#exportGLTF').onclick=()=>{
  rebuild3D(); // ensure scene is up-to-date
  const exporter=new THREE.GLTFExporter();
  exporter.parse(scene,(gltf)=>{
    const blob=new Blob([JSON.stringify(gltf)],{type:'model/gltf+json'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a');
    a.href=url; a.download='universe120.glb.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000);
  },{binary:false,onlyVisible:true});
};

/* -------------------- MAIN LOOP END -------------------- */
document.getElementById('year')?.textContent = new Date().getFullYear();
</script>

<footer style="position:fixed;left:0;right:0;bottom:0;height:0"></footer>
</body>
</html>
