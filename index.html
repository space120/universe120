<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Universe120 — 2D Architect + 4D Bubble Lab (Orthographic)</title>
<style>
:root{--bg:#f7f7fb;--card:#ffffffcc;--ink:#111;--muted:#666;--border:#e7e7ee;--brand:#3538ff}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
.site-header,.site-footer{position:fixed;left:0;right:0;display:flex;align-items:center;gap:16px;background:#fff8;backdrop-filter:saturate(1.8) blur(8px);border-bottom:1px solid var(--border);z-index:20}
.site-header{top:0;padding:10px 16px}
.site-footer{bottom:0;justify-content:center;border-top:1px solid var(--border);border-bottom:none;padding:8px 16px}
.brand{font-weight:800}
#ui.panel{position:fixed;left:16px;top:64px;z-index:15;background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px 14px;max-width:480px;box-shadow:0 6px 22px rgba(0,0,0,.07)}
#ui h1{margin:.25rem 0 .5rem;font-size:18px}
.row{display:flex;gap:8px;align-items:center;margin:.35rem 0}
label{font-size:12px;color:#444;min-width:120px}
input[type=range]{flex:1}
select,input[type=checkbox],input[type=number],input[type=text]{font-size:13px}
fieldset{border:1px dashed var(--border);border-radius:10px;padding:8px 10px;margin:.5rem 0 0}
fieldset legend{font-size:12px;color:#333;padding:0 6px}
button{appearance:none;border:1px solid var(--border);background:#fff;border-radius:10px;padding:8px 12px;font-size:13px;cursor:pointer}
button:hover{background:#f6f6ff}
button.primary{background:#3538ff;color:#fff;border-color:#3538ff}
.kbd{background:#eee;border:1px solid #ccc;border-bottom-color:#bbb;border-radius:4px;padding:0 4px;font-family:ui-monospace,Menlo,Consolas,monospace}
#canvas{display:block;width:100vw;height:100vh}
.overlay{position:fixed;right:16px;top:64px;z-index:16;background:var(--card);border:1px solid var(--border);border-radius:12px;padding:10px 12px;max-width:520px;box-shadow:0 6px 22px rgba(0,0,0,.07);font-size:13px}
@media (max-width: 700px){
  #ui.panel { max-width: 92vw; left: 4vw; }
  .row button, .row select, .row input[type=range], .row input[type=number], .row input[type=text] { min-height: 40px; }
}
.badge{font-size:11px;padding:2px 6px;border:1px solid var(--border);border-radius:999px;background:#fff}
</style>
</head>
<body>
<header class="site-header">
  <div class="brand">Universe120 <span class="badge">2D Architect + 4D Bubble Lab</span></div>
</header>

<aside id="ui" class="panel">
  <h1>Toolkit</h1>

  <div class="row">
    <label for="mode">Mode</label>
    <select id="mode">
      <option value="architect2d" selected>2D Architect</option>
      <option value="bubble4d">4D Bubble Lab</option>
    </select>
  </div>

  <!-- 2D Architect -->
  <fieldset id="arch2dBlock">
    <legend>2D Architect</legend>
    <div class="row"><label>Tool</label>
      <select id="tool2d">
        <option value="segment" selected>Segment</option>
        <option value="poly">Polyline</option>
        <option value="arc">Arc (two clicks)</option>
        <option value="circle">Circle (grid radius)</option>
        <option value="door">Door block</option>
        <option value="window">Window block</option>
        <option value="dim">Dimension</option>
        <option value="label">Room label</option>
        <option value="erase">Erase</option>
      </select>
    </div>
    <div class="row"><label>Snap</label>
      <select id="snap2d">
        <option value="intersections" selected>Intersections</option>
        <option value="centers">Circle Centers</option>
        <option value="midpoints">Midpoints</option>
        <option value="free">Free</option>
      </select>
    </div>
    <div class="row"><label>Angle Lock</label>
      <select id="lockAngle">
        <option value="off" selected>Off</option>
        <option value="ortho">0/90°</option>
        <option value="thirty">30/60/90°</option>
        <option value="fortyfive">45/90°</option>
      </select>
    </div>
    <div class="row"><label>Wall (px)</label><input id="wallThick" type="number" min="0" max="60" step="1" value="10"></div>
    <div class="row"><label>Parallel Offset</label><input id="wallOffset" type="number" min="0" max="80" step="1" value="36"> <button id="offsetBtn">Offset</button></div>
    <div class="row"><label>Stroke</label><input id="stroke2d" type="range" min="0.6" max="3" step="0.1" value="1.4"></div>

    <div class="row"><label>View</label>
      <span><input type="checkbox" id="lockView" checked> Lock View</span>
      <button id="recenter2d" type="button">Recenter</button>
      <button id="zoomReset2d" type="button">Reset Zoom</button>
    </div>

    <div class="row"><button id="undo2d">Undo</button><button id="clear2d">Clear</button><button id="exportSvg" class="primary">Export SVG</button></div>

    <div class="row"><label>Background</label>
      <input id="bgUpload" type="file" accept="image/*">
    </div>
    <div class="row"><label>BG Opacity</label><input id="bgAlpha" type="range" min="0" max="1" step="0.01" value="0.5"></div>
    <div class="row"><label>BG Scale</label><input id="bgScale" type="range" min="0.1" max="4" step="0.01" value="1"></div>
    <div class="row"><label>BG Rotate</label><input id="bgRot" type="range" min="-180" max="180" step="1" value="0"></div>
    <div class="row"><label>BG Offset</label><input id="bgOffX" type="number" value="0" style="width:80px"> <input id="bgOffY" type="number" value="0" style="width:80px"></div>

    <div class="row"><label>Calibrate</label>
      <button id="calibStart">Pick 2 pts</button>
      <input id="calibSteps" type="number" min="1" max="50" step="1" value="4" title="Grid steps between picks" style="width:80px">
    </div>

    <p style="font-size:11px;color:#666">Tips: <span class="kbd">Shift</span> strong snap • Double-click ends polyline • View is locked so you don’t lose your place</p>
  </fieldset>

  <!-- 4D Bubble Lab -->
  <fieldset id="lab4dBlock" style="display:none">
    <legend>4D Bubble Lab (Orthographic)</legend>

    <div class="row"><label>Tool</label>
      <select id="tool4d">
        <option value="hseg" selected>Hyper-Segment</option>
        <option value="hpoly">Hyper-Polyline</option>
        <option value="erase4">Erase</option>
      </select>
    </div>

    <div class="row"><label>Lattice Size</label>
      <input id="N4" type="number" min="2" max="9" step="1" value="5" style="width:80px">
      <button id="regen4">Rebuild</button>
    </div>

    <div class="row"><label>Rotate xw/yw/zw</label></div>
    <div class="row"><label>xw</label><input id="ax_xw" type="range" min="-180" max="180" step="1" value="-20"></div>
    <div class="row"><label>yw</label><input id="ax_yw" type="range" min="-180" max="180" step="1" value="20"></div>
    <div class="row"><label>zw</label><input id="ax_zw" type="range" min="-180" max="180" step="1" value="-10"></div>

    <div class="row"><label>Slice |W| ≤</label><input id="sliceW" type="range" min="0" max="1" step="0.01" value="1.00"></div>
    <div class="row"><label>Scale</label><input id="scale4" type="range" min="0.4" max="2" step="0.01" value="1.10"></div>
    <div class="row"><label>Stroke</label><input id="stroke4" type="range" min="0.6" max="3" step="0.1" value="1.4"></div>
    <div class="row"><label>Node Radius</label><input id="nodeR" type="range" min="2" max="10" step="0.1" value="4.5"></div>

    <div class="row"><button id="undo4">Undo</button><button id="clear4">Clear</button>
      <button id="export4json" class="primary">Export JSON</button>
    </div>
    <p style="font-size:11px;color:#666">Orthographic 4-D→2-D projection • Equal spacing • Uniform circles • Drag = rotate (XY/XZ) • Sliders rotate xw/yw/zw</p>
  </fieldset>
</aside>

<div id="coach" class="overlay"></div>
<canvas id="canvas"></canvas>

<footer class="site-footer">
  <small>© <span id="year"></span> Universe120 • Learn by building</small>
</footer>

<script>
document.getElementById('year').textContent = new Date().getFullYear();

function startApp(){
const canvas = document.getElementById('canvas');
const coach  = document.getElementById('coach');
const ctx = canvas.getContext('2d',{alpha:true});
let DPR = Math.min(devicePixelRatio||1,2);
function resize(){ const w=innerWidth,h=innerHeight; canvas.style.width=w+'px'; canvas.style.height=h+'px'; canvas.width=Math.round(w*DPR); canvas.height=Math.round(h*DPR); ctx.setTransform(DPR,0,0,DPR,0,0); }
addEventListener('resize',resize); resize();

const $=id=>document.getElementById(id);
const ui={
  mode:$('mode'),
  // 2D
  arch2dBlock:$('arch2dBlock'), tool2d:$('tool2d'), snap2d:$('snap2d'), lockAngle:$('lockAngle'),
  wallThick:$('wallThick'), wallOffset:$('wallOffset'), offsetBtn:$('offsetBtn'),
  stroke2d:$('stroke2d'), lockView:$('lockView'), recenter2d:$('recenter2d'), zoomReset2d:$('zoomReset2d'),
  undo2d:$('undo2d'), clear2d:$('clear2d'), exportSvg:$('exportSvg'),
  bgUpload:$('bgUpload'), bgAlpha:$('bgAlpha'), bgScale:$('bgScale'), bgRot:$('bgRot'), bgOffX:$('bgOffX'), bgOffY:$('bgOffY'),
  calibStart:$('calibStart'), calibSteps:$('calibSteps'),
  // 4D
  lab4dBlock:$('lab4dBlock'), tool4d:$('tool4d'), N4:$('N4'), regen4:$('regen4'),
  ax_xw:$('ax_xw'), ax_yw:$('ax_yw'), ax_zw:$('ax_zw'),
  sliceW:$('sliceW'), scale4:$('scale4'), stroke4:$('stroke4'), nodeR:$('nodeR'),
  undo4:$('undo4'), clear4:$('clear4'), export4json:$('export4json')
};

ui.mode.addEventListener('change', ()=>{
  ui.arch2dBlock.style.display = ui.mode.value==='architect2d' ? '' : 'none';
  ui.lab4dBlock.style.display  = ui.mode.value==='bubble4d'   ? '' : 'none';
});

let pan={x:0,y:0}, zoom=1;
function recenter(){ pan.x=0; pan.y=0; }
function resetZoom(){ zoom=1; }
ui.recenter2d.addEventListener('click', recenter);
ui.zoomReset2d.addEventListener('click', resetZoom);

/* ===================== 2D ARCHITECT (unchanged core) ===================== */
const ORIGIN={x:0,y:0};
const Rbase=26;
function gridParams(){ const R=Rbase*zoom, stepX=R, stepY=R*Math.sqrt(3)/2; return {R,stepX,stepY}; }

const sketch=[]; let polyLive=null, arcStart=null, hoverPoint=null;

function centersNear(x,y,range=3){
  const {stepX,stepY}=gridParams();
  const rr=Math.round(y/stepY), cc=Math.round((x-(rr%2? stepX/2:0))/stepX);
  const pts=[];
  for(let dr=-range;dr<=range;dr++)
    for(let dc=-range;dc<=range;dc++){
      const r=rr+dr,c=cc+dc,gx=c*stepX+(r%2? stepX/2:0), gy=r*stepY;
      pts.push({x:gx,y:gy,kind:'center'});
    }
  const mids=[];
  for(let i=0;i<pts.length;i++){
    const a=pts[i];
    for(let j=i+1;j<pts.length;j++){
      const b=pts[j]; if(Math.hypot(a.x-b.x,a.y-b.y) < stepX*1.02){ mids.push({x:(a.x+b.x)/2,y:(a.y+b.y)/2,kind:'mid'}); }
    }
  }
  return pts.concat(mids);
}
function snap2D(clientX,clientY,strong){
  const {stepX,stepY}=gridParams();
  if(ui.snap2d.value==='free') return {x:clientX,y:clientY};
  const x = clientX - (pan.x % stepX);
  const y = clientY - (pan.y % stepY);
  const cand = centersNear(x,y,strong?4:3);
  let best=null,bd=1e9;
  cand.forEach(p=>{
    const sx=p.x + (pan.x % stepX), sy=p.y + (pan.y % stepY);
    const d2=(sx-clientX)*(sx-clientX)+(sy-clientY)*(sy-clientY);
    if(d2<bd){bd=d2; best={x:sx,y:sy,kind:p.kind};}
  });
  return best || {x:clientX,y:clientY,kind:'free'};
}
function applyAngleLock(a0,a1,mode){
  if(mode==='off') return a1;
  const dx=a1.x-a0.x, dy=a1.y-a0.y, ang=Math.atan2(dy,dx);
  let snaps=[];
  if(mode==='ortho') snaps=[0,Math.PI/2,Math.PI,3*Math.PI/2];
  else if(mode==='thirty') snaps=[0,Math.PI/6,Math.PI/3,Math.PI/2,2*Math.PI/3,5*Math.PI/6,Math.PI,7*Math.PI/6,4*Math.PI/3,3*Math.PI/2,5*Math.PI/3,11*Math.PI/6];
  else if(mode==='fortyfive') snaps=[0,Math.PI/4,Math.PI/2,3*Math.PI/4,Math.PI,5*Math.PI/4,3*Math.PI/2,7*Math.PI/4];
  let best=ang,bd=1e9; snaps.forEach(s=>{const d=Math.abs(((ang-s+Math.PI)%(2*Math.PI))-Math.PI); if(d<bd){bd=d;best=s;}});
  const len=Math.hypot(dx,dy);
  return {x:a0.x+Math.cos(best)*len,y:a0.y+Math.sin(best)*len};
}
function drawGrid2D(){
  const {R,stepX,stepY}=gridParams();
  const w=canvas.width/DPR,h=canvas.height/DPR;
  ctx.save();
  ctx.translate((w/2 + ORIGIN.x) % stepX, (h/2 + ORIGIN.y) % stepY);
  ctx.lineWidth=0.9; ctx.strokeStyle='#00000018';
  const cols=Math.ceil(w/stepX)+4, rows=Math.ceil(h/stepY)+4;
  for(let r=-2;r<rows;r++){
    for(let c=-2;c<cols;c++){
      const x=c*stepX+(r%2? stepX/2:0), y=r*stepY;
      ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.stroke();
    }
  }
  ctx.restore();
}
/* Background & draw tools (same as previous) */
const bg={img:null, alpha:0.5, scale:1, rot:0, offX:0, offY:0, calib:[]};
['bgAlpha','bgScale','bgRot','bgOffX','bgOffY'].forEach(id=>$(id).addEventListener('input',()=>{}));
ui.bgUpload.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const fr=new FileReader(); fr.onload=()=>{ const im=new Image(); im.onload=()=>{ bg.img=im; }; im.src=fr.result; }; fr.readAsDataURL(f);
});
ui.calibStart.addEventListener('click', ()=>{ bg.calib=[]; alert('Calibration: click two points on the photo that should be N grid steps apart (set N).'); calibMode=true; });
let calibMode=false;
canvas.addEventListener('click', e=>{
  if(ui.mode.value!=='architect2d' || !calibMode || !bg.img) return;
  const p={x:e.clientX, y:e.clientY}; bg.calib.push(p);
  if(bg.calib.length===2){
    const N= Math.max(1, +ui.calibSteps.value||4);
    const dx=bg.calib[1].x - bg.calib[0].x, dy=bg.calib[1].y - bg.calib[0].y;
    const dist=Math.hypot(dx,dy);
    const {stepX}=gridParams(); const target = N*stepX; const s = target / dist;
    bg.scale *= s; bg.rot = Math.atan2(dy,dx);
    const snapped = snap2D(bg.calib[0].x, bg.calib[0].y, true);
    bg.offX += snapped.x - bg.calib[0].x; bg.offY += snapped.y - bg.calib[0].y;
    calibMode=false; bg.calib=[];
    alert('Calibrated. Adjust fine controls if needed.');
  }
});
function addSeg(A,B,wall){ sketch.push({type:'seg', a:A, b:B, wall:wall||0}); }
function addDoor(center,dirLen=40, swing=1){ sketch.push({type:'door',c:center,len:dirLen,swing}); }
function addWindow(A,B){ sketch.push({type:'window',a:A,b:B}); }
function addDim(A,B,label){ sketch.push({type:'dim',a:A,b:B,text:label||''}); }
function addLabel(P,text){ sketch.push({type:'label',p:P,text:text||'Room'}); }
ui.undo2d.addEventListener('click', ()=>{ sketch.pop(); });
ui.clear2d.addEventListener('click', ()=>{ sketch.length=0; });
ui.offsetBtn.addEventListener('click', ()=>{
  const off=+ui.wallOffset.value||0;
  const last=[...sketch].reverse().find(d=>d.type==='seg'); if(!last){ alert('Draw a wall segment first.'); return; }
  const nx = last.b.y-last.a.y, ny=-(last.b.x-last.a.x); const L=Math.hypot(nx,ny)||1; const ux=nx/L, uy=ny/L;
  const A={x:last.a.x+ux*off, y:last.a.y+uy*off}, B={x:last.b.x+ux*off, y:last.b.y+uy*off}; addSeg(A,B,last.wall);
});
ui.exportSvg.addEventListener('click', ()=>{
  const w=canvas.width/DPR,h=canvas.height/DPR, sw=+ui.stroke2d.value;
  const out=[];
  out.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" fill="none">`);
  out.push(`<g id="walls" stroke="#111" stroke-width="${sw}">`); sketch.forEach(d=>{ if(d.type==='seg'){ out.push(`<line x1="${d.a.x}" y1="${d.a.y}" x2="${d.b.x}" y2="${d.b.y}"/>`); }}); out.push(`</g>`);
  out.push(`<g id="arcs" stroke="#111" stroke-width="${sw}">`); sketch.forEach(d=>{ if(d.type==='arc'){ const x1=d.c.x+d.r*Math.cos(d.a1), y1=d.c.y+d.r*Math.sin(d.a1); const x2=d.c.x+d.r*Math.cos(d.a2), y2=d.c.y+d.r*Math.sin(d.a2); out.push(`<path d="M ${x1} ${y1} A ${d.r} ${d.r} 0 0 ${d.ccw?1:0} ${x2} ${y2}"/>`); }}); out.push(`</g>`);
  out.push(`<g id="doors" stroke="#0077ff" stroke-width="${sw}">`); sketch.forEach(d=>{ if(d.type==='door'){ out.push(`<circle cx="${d.c.x}" cy="${d.c.y}" r="2"/>`); }}); out.push(`</g>`);
  out.push(`<g id="windows" stroke="#00aa66" stroke-width="${sw}">`); sketch.forEach(d=>{ if(d.type==='window'){ out.push(`<line x1="${d.a.x}" y1="${d.a.y}" x2="${d.b.x}" y2="${d.b.y}"/>`); }}); out.push(`</g>`);
  out.push(`<g id="dims" stroke="#cc0000" stroke-width="${Math.max(1,sw-0.4)}" fill="#cc0000">`); sketch.forEach(d=>{ if(d.type==='dim'){ const mx=(d.a.x+d.b.x)/2, my=(d.a.y+d.b.y)/2; out.push(`<line x1="${d.a.x}" y1="${d.a.y}" x2="${d.b.x}" y2="${d.b.y}"/>`); out.push(`<text x="${mx+4}" y="${my-4}" font-size="12">${d.text||''}</text>`); }}); out.push(`</g>`);
  out.push(`<g id="labels" fill="#333">`); sketch.forEach(d=>{ if(d.type==='label'){ out.push(`<text x="${d.p.x}" y="${d.p.y}" font-size="14">${(d.text||'Room')}</text>`); }}); out.push(`</g></svg>`);
  const blob = new Blob([out.join('\n')],{type:'image/svg+xml'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='universe120-plan.svg'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1500);
});
/* Drawing input */
let dragging=false, spacePan=false;
canvas.addEventListener('mousedown', e=>{
  if(ui.mode.value!=='architect2d'){ dragging=true; return; }
  if(e.button!==0) return;
  const strong=e.shiftKey; let P = snap2D(e.clientX,e.clientY,strong);
  const tool=ui.tool2d.value;
  if(tool==='segment'){
    if(!polyLive) polyLive={points:[P]};
    else{ let A=polyLive.points[polyLive.points.length-1], B=P; B = applyAngleLock(A,B,ui.lockAngle.value); addSeg(A,B,+ui.wallThick.value||0); polyLive=null; }
  } else if(tool==='poly'){
    if(!polyLive) polyLive={points:[P]};
    else{ let A=polyLive.points[polyLive.points.length-1], B=P; B = applyAngleLock(A,B,ui.lockAngle.value); polyLive.points.push(B); addSeg(A,B,+ui.wallThick.value||0); }
  } else if(tool==='arc'){
    if(!arcStart) arcStart=P;
    else{ const mx=(arcStart.x+P.x)/2, my=(arcStart.y+P.y)/2, r=Math.hypot(P.x-arcStart.x,P.y-arcStart.y)/2; const a1=Math.atan2(arcStart.y-my,arcStart.x-mx), a2=Math.atan2(P.y-my,P.x-mx); sketch.push({type:'arc', c:{x:mx,y:my}, r, a1, a2, ccw:false}); arcStart=null; }
  } else if(tool==='circle'){ const {R}=gridParams(); sketch.push({type:'circ', c:{x:P.x,y:P.y}, r:R}); }
  else if(tool==='door'){ addDoor(P, 40, 1); }
  else if(tool==='window'){ if(!polyLive) polyLive={points:[P]}; else { addWindow(polyLive.points[0], P); polyLive=null; } }
  else if(tool==='dim'){ if(!polyLive) polyLive={points:[P]}; else { const A=polyLive.points[0], B=P; const len = Math.hypot(B.x-A.x, B.y-A.y).toFixed(1); addDim(A,B, `${len}px`); polyLive=null; } }
  else if(tool==='label'){ const text=prompt('Room name (e.g., Kitchen):','Room')||'Room'; addLabel(P,text); }
  else if(tool==='erase'){
    let bi=-1, bd=1e9;
    sketch.forEach((d,i)=>{
      let cx=0,cy=0;
      if(d.type==='seg'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;}
      else if(d.type==='arc'){cx=d.c.x;cy=d.c.y;}
      else if(d.type==='circ'){cx=d.c.x;cy=d.c.y;}
      else if(d.type==='door'){cx=d.c.x;cy=d.c.y;}
      else if(d.type==='window'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;}
      else if(d.type==='dim'){cx=(d.a.x+d.b.x)/2;cy=(d.a.y+d.b.y)/2;}
      else if(d.type==='label'){cx=d.p.x;cy=d.p.y;}
      const dd=(cx-P.x)*(cx-P.x)+(cy-P.y)*(cy-P.y); if(dd<bd){bd=dd; bi=i;}
    });
    if(bi>=0) sketch.splice(bi,1);
  }
});
addEventListener('dblclick', e=>{ if(ui.mode.value==='architect2d' && polyLive) polyLive=null; });
addEventListener('mousemove', e=>{
  if(ui.mode.value==='architect2d'){
    hoverPoint = snap2D(e.clientX,e.clientY,false);
    if(!ui.lockView.checked && (spacePan || dragging)){ pan.x += (e.movementX||0); pan.y += (e.movementY||0); }
  } else if(ui.mode.value==='bubble4d' && dragging){
    rot4.xy += (e.movementX||0)*0.003;
    rot4.xz += (e.movementY||0)*0.003;
  }
});
addEventListener('mouseup', ()=>{ dragging=false; });
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const f=Math.exp(-e.deltaY*0.001);
  if(ui.mode.value==='architect2d'){
    const before=zoom; zoom = Math.max(0.25, Math.min(5, zoom*f));
    if(ui.lockView.checked){ recenter(); }
    else{
      const w=canvas.width/DPR, h=canvas.height/DPR; const cx=w/2, cy=h/2;
      pan.x = cx - (cx - pan.x) * (zoom/before);
      pan.y = cy - (cy - pan.y) * (zoom/before);
    }
  } else {
    scale4 = Math.max(0.5, Math.min(2.2, scale4 * f));
  }
},{passive:false});
addEventListener('keydown', e=>{ if(e.code==='Space'){ spacePan=true; dragging=true; } });
addEventListener('keyup',   e=>{ if(e.code==='Space'){ spacePan=false; dragging=false; } });

/* ===================== 4D BUBBLE LAB (ORTHOGRAPHIC) ===================== */
let scale4=1.10;
let rot4={xy:0.0,xz:0.0,yz:0.0}; // camera-like
const lab={ nodes:[], edges:[] };
let hyperLive=null;

// Build a regular 4-D hypercubic lattice in [-1,1]^4 (equal spacing)
function rebuild4D(){
  const N = Math.max(2, Math.min(9, +ui.N4.value||5));
  lab.nodes.length=0; lab.edges.length=0;
  for(let i=0;i<N;i++){
    const x = (N===1?0 : i/(N-1))*2 - 1;
    for(let j=0;j<N;j++){
      const y = (N===1?0 : j/(N-1))*2 - 1;
      for(let k=0;k<N;k++){
        const z = (N===1?0 : k/(N-1))*2 - 1;
        for(let l=0;l<N;l++){
          const w = (N===1?0 : l/(N-1))*2 - 1;
          lab.nodes.push({x,y,z,w});
        }
      }
    }
  }
}
ui.regen4.addEventListener('click', rebuild4D);
['ax_xw','ax_yw','ax_zw','sliceW','scale4','stroke4','nodeR'].forEach(id=>$(id).addEventListener('input',()=>{}));
ui.undo4.addEventListener('click', ()=>{ lab.edges.pop(); });
ui.clear4.addEventListener('click', ()=>{ lab.edges.length=0; });
ui.export4json.addEventListener('click', ()=>{
  const data={nodes:lab.nodes, edges:lab.edges};
  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='universe120-4d.json'; a.click();
  setTimeout(()=>URL.revokeObjectURL(url),1500);
});

// Rotate in specific planes (orthonormal)
function rotPlane(a,b,theta){ const c=Math.cos(theta), s=Math.sin(theta); return [a*c - b*s, a*s + b*c]; }

// *** Core: Orthographic 4-D → 2-D projection with uniform scale ***
function project4Dto2D(P){
  const axw=(+ui.ax_xw.value||0)*Math.PI/180;
  const ayw=(+ui.ax_yw.value||0)*Math.PI/180;
  const azw=(+ui.ax_zw.value||0)*Math.PI/180;
  let {x,y,z,w}=P;

  // rotate in 4D (user sliders)
  [x,w]=rotPlane(x,w,axw);
  [y,w]=rotPlane(y,w,ayw);
  [z,w]=rotPlane(z,w,azw);

  // camera-ish rotations in 3D subspace for view control
  [x,y]=rotPlane(x,y,rot4.xy);
  [x,z]=rotPlane(x,z,rot4.xz);

  // slice by |w| (hides nodes but DOES NOT scale them)
  const slice=+ui.sliceW.value;
  if(Math.abs(w)>slice) return null;

  // pure linear (orthographic) 4D→2D mapping; tuned so axes don't collapse
  // Take X,Y directly, and blend a little Z,W to spread nicely.
  const sx = x + 0.5*z + 0.35*w;
  const sy = y + 0.5*z - 0.35*w;

  return {sx, sy};
}

function screenXY(pt){
  const s = 180*(+ui.scale4.value||1);
  const cx = canvas.width/DPR/2, cy=canvas.height/DPR/2;
  return {x: cx + pt.sx*s, y: cy + pt.sy*s};
}

function nearestProjectedNode(mx,my){
  let best=-1, bd=1e9, bestPt=null;
  for(let i=0;i<lab.nodes.length;i++){
    const P=project4Dto2D(lab.nodes[i]); if(!P) continue;
    const S=screenXY(P);
    const d2=(S.x-mx)*(S.x-mx)+(S.y-my)*(S.y-my);
    if(d2<bd){ bd=d2; best=i; bestPt={screen:S}; }
  }
  return (best>=0)? {index:best, screen:bestPt.screen} : null;
}

canvas.addEventListener('mousedown', e=>{
  if(ui.mode.value!=='bubble4d' || e.button!==0) return;
  const pick = nearestProjectedNode(e.clientX,e.clientY);
  if(!pick) return;
  const tool=ui.tool4d.value;
  if(tool==='hseg'){
    if(!hyperLive) hyperLive={start:pick.index};
    else{ lab.edges.push({A:hyperLive.start, B:pick.index}); hyperLive=null; }
  } else if(tool==='hpoly'){
    if(!hyperLive) hyperLive={points:[pick.index]};
    else{ const last = hyperLive.points[hyperLive.points.length-1]; lab.edges.push({A:last, B:pick.index}); hyperLive.points.push(pick.index); }
  } else if(tool==='erase4'){
    // remove closest edge by midpoint distance
    let bi=-1, bd=1e9;
    for(let i=0;i<lab.edges.length;i++){
      const eij=lab.edges[i];
      const Pa=project4Dto2D(lab.nodes[eij.A]);
      const Pb=project4Dto2D(lab.nodes[eij.B]);
      if(!Pa||!Pb) continue;
      const Sa=screenXY(Pa), Sb=screenXY(Pb);
      const mxp=(Sa.x+Sb.x)/2, myp=(Sa.y+Sb.y)/2;
      const d2=(mxp-e.clientX)*(mxp-e.clientX)+(myp-e.clientY)*(myp-e.clientY);
      if(d2<bd){ bd=d2; bi=i; }
    }
    if(bi>=0) lab.edges.splice(bi,1);
  }
});

/* ===================== SHARED RENDER LOOP ===================== */
function drawBackground(){
  if(!bg.img || ui.mode.value!=='architect2d') return;
  const w=canvas.width/DPR,h=canvas.height/DPR;
  ctx.save(); ctx.globalAlpha=bg.alpha;
  ctx.translate(w/2 + bg.offX, h/2 + bg.offY); ctx.rotate(bg.rot); ctx.scale(bg.scale, bg.scale);
  ctx.drawImage(bg.img, -bg.img.width/2, -bg.img.height/2);
  ctx.restore();
}

let last=0;
function render(t){
  if(t-last<14){ requestAnimationFrame(render); return; }
  last=t;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round';

  if(ui.mode.value==='architect2d'){
    drawBackground();
    drawGrid2D();
    ctx.lineWidth=+ui.stroke2d.value; ctx.strokeStyle='#111'; ctx.fillStyle='#111';
    sketch.forEach(d=>{
      if(d.type==='seg'){ ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke();
        if(d.wall>0){ const nx = d.b.y-d.a.y, ny=-(d.b.x-d.a.x); const L=Math.hypot(nx,ny)||1; const ux=nx/L, uy=ny/L, tt=d.wall/2;
          ctx.beginPath(); ctx.moveTo(d.a.x+ux*tt,d.a.y+uy*tt); ctx.lineTo(d.b.x+ux*tt,d.b.y+uy*tt); ctx.lineTo(d.b.x-ux*tt,d.b.y-uy*tt); ctx.lineTo(d.a.x-ux*tt,d.a.y-uy*tt); ctx.closePath(); ctx.stroke();
        }
      }
      if(d.type==='arc'){ ctx.beginPath(); ctx.arc(d.c.x,d.c.y,d.r,d.a1,d.a2,d.ccw||false); ctx.stroke(); }
      if(d.type==='circ'){ ctx.beginPath(); ctx.arc(d.c.x,d.c.y,d.r,0,Math.PI*2); ctx.stroke(); }
      if(d.type==='door'){ ctx.strokeStyle='#0077ff'; ctx.beginPath(); ctx.arc(d.c.x,d.c.y,18,0,Math.PI/2,false); ctx.stroke(); ctx.strokeStyle='#111'; }
      if(d.type==='window'){ ctx.strokeStyle='#00aa66'; ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke(); ctx.strokeStyle='#111'; }
      if(d.type==='dim'){ ctx.strokeStyle='#cc0000'; ctx.beginPath(); ctx.moveTo(d.a.x,d.a.y); ctx.lineTo(d.b.x,d.b.y); ctx.stroke();
        const mx=(d.a.x+d.b.x)/2, my=(d.a.y+d.b.y)/2; ctx.fillStyle='#cc0000'; ctx.font='12px system-ui'; ctx.fillText(d.text||'', mx+4, my-4); ctx.strokeStyle='#111'; ctx.fillStyle='#111'; }
      if(d.type==='label'){ ctx.fillStyle='#333'; ctx.font='14px system-ui'; ctx.fillText(d.text||'Room', d.p.x, d.p.y); ctx.fillStyle='#111'; }
    });
    if(hoverPoint){ ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(hoverPoint.x,hoverPoint.y,2,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#111'; }
    ctx.fillStyle='#222'; ctx.font='12px system-ui';
    ctx.fillText('2D Architect: Walls/Doors/Windows/Dimensions • SVG export • Photo calibration • View locked', 16, canvas.height/DPR-18);
  } else {
    // 4D Bubble Lab (orthographic)
    const stroke = +ui.stroke4.value||1.4;
    const rNode = +ui.nodeR.value||4.5;
    ctx.lineWidth=stroke; ctx.strokeStyle='#111'; ctx.fillStyle='#111';

    // nodes (no depth scaling; pure uniform circles)
    for(let i=0;i<lab.nodes.length;i++){
      const P=project4Dto2D(lab.nodes[i]); if(!P) continue;
      const S=screenXY(P);
      ctx.beginPath(); ctx.arc(S.x, S.y, rNode, 0, Math.PI*2); ctx.stroke();
    }

    // edges
    lab.edges.forEach(eij=>{
      const Pa=project4Dto2D(lab.nodes[eij.A]); const Pb=project4Dto2D(lab.nodes[eij.B]);
      if(!Pa||!Pb) return;
      const Sa=screenXY(Pa), Sb=screenXY(Pb);
      ctx.beginPath(); ctx.moveTo(Sa.x,Sa.y); ctx.lineTo(Sb.x,Sb.y); ctx.stroke();
    });

    // HUD
    ctx.fillStyle='#222'; ctx.font='12px system-ui';
    ctx.fillText('4D Bubble Lab (Orthographic): Equal spacing • Uniform nodes • Drag=rotate XY/XZ • Sliders rotate xw/yw/zw • Slice hides only', 16, canvas.height/DPR-18);
  }

  ctx.restore();
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

// init
rebuild4D();
coach.innerHTML = `<b>Welcome</b><br>2D: trace & draft plans. 4D: perfectly regular orthographic lattice; draw hyper-segments with uniform bubbles.`;
}
startApp();
</script>
</body>
</html>
